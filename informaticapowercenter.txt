////////////////////////////////////////
///////****** informaticapowercenter ******///////
////////////////////////////////////////

////////  REACT  ////////
(Lenguajes: CSS, HTML, JSON, JavaScript, Markdown, TypeScript)

√çNDICE DE ARCHIVOS INCLUIDOS:
 - eslint.config.js
 - index.html
 - package.json
 - README.md
 - tsconfig.app.json
 - tsconfig.json
 - tsconfig.node.json
 - tsconfig.node.tsbuildinfo
 - vite.config.ts
 - public/vite.svg
 - src/App.tsx
 - src/main.tsx
 - src/vite-env.d.ts
 - src/assets/react.svg
 - src/components/common/DataTable.tsx
 - src/components/dashboard/KPICard.tsx
 - src/components/dashboard/MappingTypeChart.tsx
 - src/components/layout/Header.tsx
 - src/components/layout/MainLayout.tsx
 - src/components/layout/Sidebar.tsx
 - src/components/mappings/MappingGraph.tsx
 - src/components/ui/Card.tsx
 - src/components/ui/Loader.tsx
 - src/components/workflow/WorkflowGraph.tsx
 - src/hooks/useEtlData.ts
 - src/hooks/useExtractionData.ts
 - src/interfaces/index.ts
 - src/interfaces/mapping.interface.ts
 - src/interfaces/multi-workflow.interface.ts
 - src/interfaces/powermart.interface.ts
 - src/interfaces/sessiones.interface.ts
 - src/interfaces/workflow.interface.ts
 - src/lib/extractor.ts
 - src/lib/mappingHelpers.ts
 - src/pages/Dashboard.tsx
 - src/pages/Details.tsx
 - src/pages/Mappings.tsx
 - src/pages/NotFound.tsx
 - src/pages/Sessions.tsx
 - src/pages/Sources.tsx
 - src/pages/Targets.tsx
 - src/pages/Workflows.tsx
 - src/router/index.tsx
 - src/services/etlService.ts
 - src/styles/index.css
 - src/types/extraction.ts

================================================================================

// eslint.config.js

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


--------------------------------------------------------------------------------

<!-- index.html -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


--------------------------------------------------------------------------------

// package.json

{
  "name": "informaticapowercenter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "extract": "tsx src/lib/extractor.ts"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.13",
    "@tanstack/react-table": "^8.21.3",
    "@tanstack/react-virtual": "^3.13.12",
    "lucide-react": "^0.544.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^6.25.1",
    "reactflow": "^11.11.4",
    "recharts": "^3.2.1",
    "sonner": "^2.0.7",
    "tailwindcss": "^4.1.13",
    "xml2js": "^0.6.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/react": "^19.1.13",
    "@types/react-dom": "^19.1.9",
    "@types/xml2js": "^0.4.14",
    "@vitejs/plugin-react": "^5.0.3",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.4.0",
    "tsx": "^4.20.5",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.44.0",
    "vite": "^7.1.7"
  }
}


--------------------------------------------------------------------------------

** README.md **

# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```


--------------------------------------------------------------------------------

// tsconfig.app.json

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


--------------------------------------------------------------------------------

// tsconfig.json

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


--------------------------------------------------------------------------------

// tsconfig.node.json

{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "allowImportingTsExtensions": true,
    "strict": true,
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true
  },
  "include": ["vite.config.ts","src/lib/**/*.ts", "src/lib/mappingHelpers.js"]
}


--------------------------------------------------------------------------------

// tsconfig.node.tsbuildinfo

{"root":["./vite.config.ts","./src/lib/extractor.ts","./src/lib/mappinghelpers.ts"],"errors":true,"version":"5.8.3"}


--------------------------------------------------------------------------------

// vite.config.ts

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
})


--------------------------------------------------------------------------------

// public/vite.svg

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>


--------------------------------------------------------------------------------

// src/App.tsx

import { RouterProvider } from "react-router-dom";
import { router } from "./router";

function App() {
  return <RouterProvider router={router} />;
}

export default App;


--------------------------------------------------------------------------------

// src/main.tsx

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './styles/index.css' // Actualiza la ruta a los estilos
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


--------------------------------------------------------------------------------

// src/vite-env.d.ts

/// <reference types="vite/client" />


--------------------------------------------------------------------------------

// src/assets/react.svg

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>


--------------------------------------------------------------------------------

// src/components/common/DataTable.tsx

import {
  type ColumnDef,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getSortedRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { useVirtualizer } from "@tanstack/react-virtual";
import React from "react";

/**
 * DataTable gen√©rica con soporte opcional de virtualizaci√≥n.
 * - data: filas
 * - columns: ColumnDef<T>[]
 * - height: alto del contenedor para virtualizaci√≥n (px)
 * - virtualized: activar/desactivar virtualizaci√≥n
 */
export function DataTable<T>({
  data,
  columns,
  virtualized = false,
  height = 520,
}: {
  data: T[];
  columns: ColumnDef<T, any>[];
  virtualized?: boolean;
  height?: number;
}) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    state: {},
  });

  const rows = table.getRowModel().rows;

  // Virtualizaci√≥n de filas (opcional)
  const parentRef = React.useRef<HTMLDivElement>(null);
  const rowVirtualizer = useVirtualizer({
    count: rows.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 40,
    overscan: 8,
  });

  const items = virtualized
    ? rowVirtualizer.getVirtualItems()
    : rows.map((_, i) => ({ index: i } as any));

  return (
    <div className="rounded-xl border bg-white shadow-sm">
      <div className="overflow-x-auto">
        <table className="min-w-full text-sm">
          <thead className="sticky top-0 z-10 bg-gray-50">
            {table.getHeaderGroups().map((hg) => (
              <tr key={hg.id}>
                {hg.headers.map((h) => (
                  <th
                    key={h.id}
                    className="px-3 py-2 text-left font-semibold text-gray-700"
                  >
                    {h.isPlaceholder
                      ? null
                      : flexRender(h.column.columnDef.header, h.getContext())}
                  </th>
                ))}
              </tr>
            ))}
          </thead>
        </table>
      </div>

      <div
        ref={parentRef}
        className="overflow-auto"
        style={{ height: virtualized ? height : "auto" }}
      >
        <table className="min-w-full text-sm">
          <tbody
            style={
              virtualized
                ? { height: rowVirtualizer.getTotalSize() }
                : undefined
            }
          >
            {items.map((vi: any) => {
              const row = rows[virtualized ? vi.index : vi.index];
              const style = virtualized
                ? ({
                    transform: `translateY(${vi.start}px)`,
                  } as React.CSSProperties)
                : undefined;
              return (
                <tr
                  key={row.id}
                  style={style}
                  className="border-t hover:bg-gray-50"
                >
                  {row.getVisibleCells().map((cell) => (
                    <td key={cell.id} className="px-3 py-2 align-top">
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </td>
                  ))}
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}


--------------------------------------------------------------------------------

// src/components/dashboard/KPICard.tsx

export function KPICard({
  label,
  value,
  hint,
}: {
  label: string;
  value: number | string;
  hint?: string;
}) {
  return (
    <div className="rounded-2xl border bg-white p-4 shadow-sm">
      <div className="text-xs uppercase tracking-wide text-gray-500">
        {label}
      </div>
      <div className="mt-1 text-2xl font-semibold text-gray-900">{value}</div>
      {hint ? <div className="mt-1 text-xs text-gray-500">{hint}</div> : null}
    </div>
  );
}


--------------------------------------------------------------------------------

// src/components/dashboard/MappingTypeChart.tsx

import {
  Bar,
  BarChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

type Mapping = {
  name: string;
  transformations?: { type: string }[];
};

export default function MappingTypeChart({
  mappings,
}: {
  mappings: Mapping[];
}) {
  const counts: Record<string, number> = {};
  mappings?.forEach((m) =>
    m.transformations?.forEach((t) => {
      counts[t.type] = (counts[t.type] ?? 0) + 1;
    })
  );
  const data = Object.entries(counts).map(([type, count]) => ({ type, count }));

  return (
    <div className="h-72 rounded-2xl border bg-white p-4 shadow-sm">
      <ResponsiveContainer width="100%" height="100%">
        <BarChart data={data}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="type" />
          <YAxis allowDecimals={false} />
          <Tooltip />
          <Bar dataKey="count" />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}


--------------------------------------------------------------------------------

// src/components/layout/Header.tsx

import type { Dispatch, SetStateAction } from "react";

interface HeaderProps {
  searchTerm: string;
  setSearchTerm: Dispatch<SetStateAction<string>>;
}

export const Header = ({ searchTerm, setSearchTerm }: HeaderProps) => (
  <header className="bg-white shadow-md p-4 flex justify-between items-center">
    <h1 className="text-2xl font-bold text-gray-800">Dashboard ETL</h1>
    <div className="flex items-center space-x-4">
      <input
        type="text"
        placeholder="Buscar..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        className="px-3 py-1 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
      <div className="flex items-center space-x-2">
        <span>Usuario</span>
        <div className="w-8 h-8 bg-blue-500 rounded-full"></div>
      </div>
    </div>
  </header>
);


--------------------------------------------------------------------------------

// src/components/layout/MainLayout.tsx

import { useState } from "react";
import { Outlet, useOutletContext } from "react-router-dom";
import { useEtlData } from "../../hooks/useEtlData";
import { Loader } from "../ui/Loader";
import { Header } from "./Header";
import { Sidebar } from "./Sidebar";

// Contexto para pasar datos y estado a las p√°ginas anidadas
type AppContextType = {
  data: ReturnType<typeof useEtlData>["data"];
  searchTerm: string;
};

export const MainLayout = () => {
  const [searchTerm, setSearchTerm] = useState("");
  const { data, loading, error } = useEtlData();

  if (loading) return <Loader />;
  if (error) return <div className="p-6">Error: {error}</div>;
  if (!data) return <div className="p-6">No se encontraron datos.</div>;

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        <Header searchTerm={searchTerm} setSearchTerm={setSearchTerm} />
        <main className="flex-1 overflow-y-auto p-6">
          <Outlet context={{ data, searchTerm } satisfies AppContextType} />
        </main>
      </div>
    </div>
  );
};

// Hook para acceder f√°cilmente al contexto en las p√°ginas
export function useAppData() {
  return useOutletContext<AppContextType>();
}


--------------------------------------------------------------------------------

// src/components/layout/Sidebar.tsx

import { NavLink } from "react-router-dom";
const sections = [
  { path: "/", name: "Dashboard", icon: "üè†" },
  { path: "/mappings", name: "Mappings", icon: "üîÑ" },
  { path: "/workflows", name: "Workflows", icon: "‚öôÔ∏è" },
  { path: "/sessions", name: "Sessions", icon: "üìä" },
  { path: "/sources", name: "Sources", icon: "üì•" },
  { path: "/targets", name: "Targets", icon: "üì§" },
];
export const Sidebar = () => (
  <aside className="w-64 bg-gradient-to-b from-gray-800 to-gray-900 text-white shadow-lg">
    <div className="p-4">
      <h1 className="text-xl font-bold">PowerCenter ETL</h1>
    </div>
    <nav className="mt-4">
      {sections.map((section) => (
        <NavLink
          key={section.name}
          to={section.path}
          className={({ isActive }) =>
            `w-full text-left px-4 py-2 block hover:bg-gray-700 transition-colors ${
              isActive ? "bg-gray-700" : ""
            }`
          }
        >
          <span className="mr-2">{section.icon}</span>
          {section.name}
        </NavLink>
      ))}
    </nav>
  </aside>
);


--------------------------------------------------------------------------------

// src/components/mappings/MappingGraph.tsx

// src/components/mappings/MappingGraph.tsx
import { useMemo } from "react";
import ReactFlow, { Background, Controls } from "reactflow";
import "reactflow/dist/style.css";
import type { Mapping } from "../../types/extraction";

export default function MappingGraph({ mapping }: { mapping: Mapping }) {
  const { nodes, edges } = useMemo(() => {
    const nodes = (mapping.instances ?? []).map((inst, i) => ({
      id: inst.name,
      data: { label: `${inst.transformationType}: ${inst.name}` },
      position: { x: (i % 6) * 240, y: Math.floor(i / 6) * 120 },
      style: {
        borderRadius: 12,
        padding: 8,
        background: "#fff",
        border: "1px solid #e5e7eb",
      },
    }));

    const edges = (mapping.connectors ?? []).map((c, idx) => ({
      id: `${c.fromInstance}->${c.toInstance}-${idx}`,
      source: c.fromInstance,
      target: c.toInstance,
      label:
        c.fromField && c.toField ? `${c.fromField} ‚Üí ${c.toField}` : undefined,
      animated: true,
    }));

    return { nodes, edges };
  }, [mapping]);

  return (
    <div className="h-[70vh] rounded-2xl border bg-white shadow-sm">
      <ReactFlow nodes={nodes} edges={edges} fitView>
        <Background />
        <Controls />
      </ReactFlow>
    </div>
  );
}


--------------------------------------------------------------------------------

// src/components/ui/Card.tsx

import type { ReactNode } from "react";
import { Link } from "react-router-dom";

interface CardProps {
  title: string;
  titleClassName?: string;
  children: ReactNode;
  to?: string;
  onClick?: () => void;
}

export const Card = ({
  title,
  titleClassName = "text-blue-600",
  children,
  to,
  onClick,
}: CardProps) => {
  const cardContent = (
    <>
      <h3 className={`text-lg font-semibold ${titleClassName}`}>{title}</h3>
      <div className="text-gray-600 mt-2 space-y-1">{children}</div>
    </>
  );

  if (to) {
    return (
      <Link
        to={to}
        className="block bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer"
      >
        {cardContent}
      </Link>
    );
  }

  if (onClick) {
    return (
      <button
        onClick={onClick}
        className="w-full text-left bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer"
      >
        {cardContent}
      </button>
    );
  }

  return (
    <div className="bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow">
      {cardContent}
    </div>
  );
};


--------------------------------------------------------------------------------

// src/components/ui/Loader.tsx

export const Loader = () => (
  <div className="flex justify-center items-center h-screen">
    <div className="text-xl font-semibold">Cargando datos...</div>
  </div>
);


--------------------------------------------------------------------------------

// src/components/workflow/WorkflowGraph.tsx

import { useMemo } from "react";
import ReactFlow, { Background, Controls } from "reactflow";
import "reactflow/dist/style.css";

type WorkflowTask = {
  name: string;
  taskType?: string;
};

type WorkflowLink = {
  fromTask: string;
  toTask: string;
  condition?: string;
};

type Workflow = {
  name: string;
  tasks: WorkflowTask[];
  links: WorkflowLink[];
};

export default function WorkflowGraph({ wf }: { wf: Workflow }) {
  const { nodes, edges } = useMemo(() => {
    const nodes = wf.tasks.map((t, i) => ({
      id: t.name,
      data: { label: `${t.taskType ?? "Task"}: ${t.name}` },
      position: { x: (i % 6) * 220, y: Math.floor(i / 6) * 120 },
      style: {
        borderRadius: 12,
        padding: 8,
        background: "#fff",
        border: "1px solid #e5e7eb",
      },
    }));
    const edges = wf.links.map((l) => ({
      id: `${l.fromTask}->${l.toTask}`,
      source: l.fromTask,
      target: l.toTask,
      label: l.condition,
      animated: true,
    }));
    return { nodes, edges };
  }, [wf]);

  return (
    <div className="h-[70vh] rounded-2xl border bg-white shadow-sm">
      <ReactFlow nodes={nodes} edges={edges} fitView>
        <Background />
        <Controls />
      </ReactFlow>
    </div>
  );
}


--------------------------------------------------------------------------------

// src/hooks/useEtlData.ts

import { useState, useEffect } from "react";
import type { IFlatExtractionData } from "../interfaces";
import { getEtlData } from "../services/etlService";

export const useEtlData = () => {
  const [data, setData] = useState<IFlatExtractionData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        const jsonData = await getEtlData();
        setData(jsonData);
      } catch (err) {
        setError(err instanceof Error ? err.message : "An unknown error occurred");
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, []);

  return { data, loading, error };
};


--------------------------------------------------------------------------------

// src/hooks/useExtractionData.ts

// src/hooks/useExtractionData.ts
import React from "react";
import type { Extraction } from "../types/extraction";

export function useExtractionData(path = "/extraction.json") {
  const [data, setData] = React.useState<Extraction | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    let alive = true;
    setLoading(true);
    fetch(path)
      .then((r) => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.json();
      })
      .then((json) => {
        if (alive) setData(json);
      })
      .catch((e) => {
        if (alive) setError(String(e));
      })
      .finally(() => {
        if (alive) setLoading(false);
      });
    return () => {
      alive = false;
    };
  }, [path]);

  return { data, loading, error };
}


--------------------------------------------------------------------------------

// src/interfaces/index.ts

export * from "./mapping.interface.ts";
export * from "./multi-workflow.interface.ts";
export * from "./powermart.interface.ts";
export * from "./sessiones.interface.ts";
export * from "./workflow.interface.ts";


--------------------------------------------------------------------------------

// src/interfaces/mapping.interface.ts

// src/interfaces/mapping.interface.ts

/**
 * Atributos clave-valor que definen el comportamiento de diversos elementos.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITableAttribute {
  NAME: string;
  VALUE: string;
}

/**
 * Representa un mapeo (Mapping) que define el flujo de datos.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IMapping {
  NAME: string;
  ISVALID: "YES" | "NO";
  OBJECTVERSION: string;
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  TRANSFORMATION?: ITransformation[];
  INSTANCE?: IInstance[];
  CONNECTOR?: IConnector[];
  TARGETLOADORDER?: ITargetLoadOrder[];
  MAPPINGVARIABLE?: IMappingVariable[];
  ERPINFO?: object; // Etiqueta vac√≠a en el XML
}

/**
 * Representa una transformaci√≥n dentro de un mapeo (ej. Expression, Filter).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITransformation {
  NAME: string;
  TYPE:
    | "Source Qualifier"
    | "Expression"
    | "Filter"
    | "Aggregator"
    | "Joiner"
    | "Lookup Procedure"
    | "Update Strategy"
    | "Sorter"; // A√±adido "Sorter"
  OBJECTVERSION: string;
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  TRANSFORMFIELD?: ITransformField[];
  TABLEATTRIBUTE?: ITableAttribute[];
  METADATAEXTENSION?: IMetaDataExtension[]; // Extensi√≥n de metadatos (opcional)
}

/**
 * Representa un puerto (campo) dentro de una transformaci√≥n.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITransformField {
  NAME: string;
  PORTTYPE:
    | "INPUT"
    | "OUTPUT"
    | "INPUT/OUTPUT"
    | "LOOKUP/OUTPUT"
    | "LOOKUP/RETURN/OUTPUT"
    | "INPUT/OUTPUT/MASTER";
  DATATYPE:
    | "nstring"
    | "date/time"
    | "decimal"
    | "string"
    | "integer"
    | "number(p,s)"
    | "varchar2"
    | "number"; // Tipos de datos extendidos
  PRECISION: string;
  SCALE: string;
  DEFAULTVALUE?: string;
  DESCRIPTION?: string;
  EXPRESSION?: string;
  EXPRESSIONTYPE?: "GENERAL" | "GROUPBY";
  PICTURETEXT?: string;
  // Espec√≠ficos para transformaciones Sorter
  ISSORTKEY?: "YES" | "NO";
  SORTDIRECTION?: "ASCENDING" | "DESCENDING";
}

/**
 * Instancia de una transformaci√≥n, fuente o destino dentro de un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IInstance {
  NAME: string;
  TYPE: "SOURCE" | "TARGET" | "TRANSFORMATION";
  TRANSFORMATION_NAME: string;
  TRANSFORMATION_TYPE: string;
  DESCRIPTION?: string;
  REUSABLE?: "YES" | "NO";
  DBDNAME?: string; // Presente para instancias de fuentes/destinos
  ASSOCIATED_SOURCE_INSTANCE?: {
    NAME: string;
  };
  TABLEATTRIBUTE?: ITableAttribute[]; // Las instancias tambi√©n pueden tener atributos (ej. "Table Name Prefix" para TARGET)
}

/**
 * Define la conexi√≥n entre los puertos de dos instancias en un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConnector {
  FROMFIELD: string;
  FROMINSTANCE: string;
  FROMINSTANCETYPE: string;
  TOFIELD: string;
  TOINSTANCE: string;
  TOINSTANCETYPE: string;
}

/**
 * Define el orden de carga para los destinos en un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITargetLoadOrder {
  ORDER: string;
  TARGETINSTANCE: string;
}

/**
 * Una variable definida a nivel de mapeo (ej. $$AtributoPF).
 * Los atributos se fusionan como propiedades directas.
 */
export interface IMappingVariable {
  NAME: string;
  DATATYPE: string;
  ISPARAM: "YES" | "NO";
  USERDEFINED: "YES" | "NO";
  PRECISION: string;
  SCALE: string;
  DEFAULTVALUE?: string;
  DESCRIPTION?: string;
  ISEXPRESSIONVARIABLE?: "YES" | "NO";
}

/**
 * Extensi√≥n de metadatos para transformaciones.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IMetaDataExtension {
  DATATYPE: string;
  DOMAINNAME: string;
  ISCLIENTEDITABLE: "YES" | "NO";
  ISCLIENTVISIBLE: "YES" | "NO";
  ISREUSABLE: "YES" | "NO";
  ISSHAREREAD: "YES" | "NO";
  ISSHAREWRITE: "YES" | "NO";
  MAXLENGTH: string;
  NAME: string;
  VALUE: string;
  VENDORNAME: string;
  DESCRIPTION?: string;
}


--------------------------------------------------------------------------------

// src/interfaces/multi-workflow.interface.ts

// src/interfaces/multi-workflow.interface.ts
// Importa las interfaces base sin el "$" para el mapeo
import type { IPowerMart } from "./powermart.interface";

/**
 * Helper para asegurar que un elemento siempre se trate como un array.
 * √ötil cuando `xml2js` con `explicitArray: false` devuelve un objeto simple
 * en lugar de un array de un objeto si solo hay un elemento.
 * @param item El elemento a normalizar.
 * @returns Un array de elementos (vac√≠o si es undefined/null, o con el elemento/s).
 */
export function ensureArray<T>(item: T | T[] | undefined): T[] {
  if (item === undefined || item === null) {
    return [];
  }
  if (Array.isArray(item)) {
    return item;
  }
  return [item];
}

/**
 * Estructura de datos crudos extra√≠da, coincidiendo con el XML.
 */
export interface IExtractionResult {
  POWERMART: IPowerMart;
}

/**
 * Representa la estructura de datos extra√≠da y aplanada, m√°s f√°cil de consumir por la UI.
 * Evita la anidaci√≥n profunda del XML y normaliza los tipos.
 */
export interface IFlatExtractionData {
  repositoryName: string;
  folderName: string;
  summary: {
    totalWorkflows: number;
    totalSessions: number;
    totalMappings: number;
    totalSources: number;
    totalTargets: number;
    totalTransformations: number;
  };
  mappings: IMappedMapping[];
  workflows: IMappedWorkflow[];
  sources: IMappedSource[];
  targets: IMappedTarget[];
  sessions: IMappedSession[];
  configs: IMappedConfig[];
  reusableTasks: IMappedTask[]; // Tareas definidas directamente bajo FOLDER
  allTasksInstances: IMappedTaskInstance[]; // Todas las instancias de tareas dentro de los workflows
}

/**
 * Estructura simplificada para una fuente mapeada.
 */
export interface IMappedSource {
  name: string;
  databaseType: string;
  ownerName: string;
  description?: string;
  fields: IMappedField[];
  isFlatFile: boolean;
  attributes?: IMappedAttribute[];
}

/**
 * Estructura simplificada para un destino mapeado.
 */
export interface IMappedTarget {
  name: string;
  databaseType: string;
  description?: string;
  fields: IMappedField[];
  attributes?: IMappedAttribute[];
}

/**
 * Estructura simplificada para un campo (columna) mapeado.
 */
export interface IMappedField {
  name: string;
  dataType: string;
  keyType: string;
  nullable: string;
  precision: string;
  scale: string;
  description?: string;
  length?: string;
  physicalLength?: string;
  fieldProperty?: string;
  fieldType?: string;
  hidden?: "YES" | "NO";
  level?: string;
  occurs?: string;
  offset?: string;
  usage_flags?: string;
}

/**
 * Estructura simplificada para un mapeo mapeado.
 */
export interface IMappedMapping {
  name: string;
  isValid: "YES" | "NO";
  description?: string;
  transformations: IMappedTransformation[];
  instances: IMappedInstance[];
  connectors: IMappedConnector[];
  targetLoadOrders: IMappedTargetLoadOrder[];
  variables: IMappedMappingVariable[];
}

/**
 * Estructura simplificada para una transformaci√≥n mapeada.
 */
export interface IMappedTransformation {
  name: string;
  type: string;
  description?: string;
  reusable: "YES" | "NO";
  fields: IMappedTransformField[];
  attributes: IMappedAttribute[];
  metadataExtensions?: IMappedMetadataExtension[];
}

/**
 * Estructura simplificada para un campo de transformaci√≥n mapeado.
 */
export interface IMappedTransformField {
  name: string;
  portType: string;
  dataType: string;
  precision: string;
  scale: string;
  expression?: string;
  expressionType?: string;
  description?: string;
  isSortKey?: "YES" | "NO";
  sortDirection?: "ASCENDING" | "DESCENDING";
  defaultValue?: string;
  pictureText?: string;
}

/**
 * Estructura simplificada para una instancia mapeada.
 */
export interface IMappedInstance {
  name: string;
  type: string;
  transformationName: string;
  transformationType: string;
  description?: string;
  associatedSourceInstanceName?: string;
  attributes?: IMappedAttribute[];
}

/**
 * Estructura simplificada para un conector mapeado.
 */
export interface IMappedConnector {
  fromField: string;
  fromInstance: string;
  fromInstanceType: string;
  toField: string;
  toInstance: string;
  toInstanceType: string;
}

/**
 * Estructura simplificada para un orden de carga de destino mapeado.
 */
export interface IMappedTargetLoadOrder {
  order: string;
  targetInstance: string;
}

/**
 * Estructura simplificada para una variable de mapeo mapeada.
 */
export interface IMappedMappingVariable {
  name: string;
  dataType: string;
  isParam: "YES" | "NO";
  defaultValue?: string;
  precision: string;
  scale: string;
  isExpressionVariable?: "YES" | "NO";
  userDefined: "YES" | "NO";
  description?: string;
}

/**
 * Estructura simplificada para una extensi√≥n de metadatos mapeada.
 */
export interface IMappedMetadataExtension {
  name: string;
  value: string;
  dataType: string;
  description?: string;
  vendorName: string;
  domainName: string;
  isClientEditable: "YES" | "NO";
  isClientVisible: "YES" | "NO";
  isReusable: "YES" | "NO";
  isShareRead: "YES" | "NO";
  isShareWrite: "YES" | "NO";
  maxLength: string;
}

/**
 * Estructura simplificada para un workflow mapeado.
 */
export interface IMappedWorkflow {
  name: string;
  isValid: "YES" | "NO";
  isEnabled: "YES" | "NO";
  description?: string;
  serverName: string;
  tasks: IMappedTaskInstance[]; // Instancias de tareas/sesiones dentro de este workflow
  links: IMappedWorkflowLink[];
  variables: IMappedWorkflowVariable[];
  attributes: IMappedAttribute[];
  scheduler: IMappedScheduler;
}

/**
 * Estructura simplificada para una instancia de tarea mapeada.
 */
export interface IMappedTaskInstance {
  name: string;
  taskName: string;
  taskType: string;
  isEnabled: "YES" | "NO";
  failParentIfFails?: "YES" | "NO";
  failParentIfDidNotRun?: "YES" | "NO";
  treatInputLinkAsAnd?: "YES" | "NO";
  attributes?: IMappedAttribute[];
  // sessionExtensions?: IMappedSessionExtension[]; // Si las extensiones est√°n directamente bajo la instancia de tarea (no en este XML)
  description?: string;
  reusable?: "YES" | "NO";
  decisionName?: string;
}

/**
 * Estructura simplificada para un enlace de workflow mapeado.
 */
export interface IMappedWorkflowLink {
  fromTask: string;
  toTask: string;
  condition?: string;
}

/**
 * Estructura simplificada para una variable de workflow mapeada.
 */
export interface IMappedWorkflowVariable {
  name: string;
  dataType: string;
  userDefined: "YES" | "NO";
  defaultValue?: string;
  isPersistent: "YES" | "NO";
  description?: string;
  isNull: "YES" | "NO";
}

/**
 * Estructura simplificada para un scheduler mapeado.
 */
export interface IMappedScheduler {
  name: string;
  scheduleType: string;
  description?: string;
}

/**
 * Estructura simplificada para una sesi√≥n mapeada.
 */
export interface IMappedSession {
  name: string;
  mappingName: string;
  isValid: "YES" | "NO";
  description?: string;
  transformationInstances: IMappedSessTransformationInst[];
  sessionExtensions: IMappedSessionExtension[];
  attributes: IMappedAttribute[];
  configReferenceName: string;
  sessionComponents?: IMappedSessionComponent[];
  reusable: "YES" | "NO";
  versionNumber: string;
  sortOrder?: string;
}

/**
 * Estructura simplificada para una instancia de transformaci√≥n de sesi√≥n mapeada.
 */
export interface IMappedSessTransformationInst {
  instanceName: string;
  transformationName: string;
  transformationType: string;
  pipeline: string;
  stage: string;
  isRepartitionPoint: "YES" | "NO";
  partitionType: string;
  attributes?: IMappedAttribute[];
  partition?: {
    name: string;
    description?: string;
  }[];
}

/**
 * Estructura simplificada para una extensi√≥n de sesi√≥n mapeada.
 */
export interface IMappedSessionExtension {
  name: string;
  instanceName: string;
  subType: string;
  transformationType: string;
  type: string;
  connectionReference?: IMappedConnectionReference;
  attributes: IMappedAttribute[];
  dsqInstanceName?: string;
  dsqInstanceType?: string;
}

/**
 * Estructura simplificada para una referencia de conexi√≥n mapeada.
 */
export interface IMappedConnectionReference {
  name: string;
  type: string;
  variable: string;
  connectionName?: string;
  connectionNumber?: string;
  connectionSubtype?: string;
}

/**
 * Estructura simplificada para un componente de sesi√≥n mapeado.
 */
export interface IMappedSessionComponent {
  refObjectName: string;
  reusable: "YES" | "NO";
  type: string;
}

/**
 * Estructura simplificada para un atributo mapeado.
 */
export interface IMappedAttribute {
  name: string;
  value: string;
}

/**
 * Estructura simplificada para una configuraci√≥n mapeada.
 */
export interface IMappedConfig {
  name: string;
  isDefault: "YES" | "NO";
  description?: string;
  attributes: IMappedAttribute[];
  versionNumber: string;
}

/**
 * Estructura simplificada para una tarea reutilizable mapeada (definida en la carpeta).
 */
export interface IMappedTask {
  name: string;
  type: string;
  description?: string;
  reusable: "YES" | "NO";
  attributes?: IMappedAttribute[];
  valuePairs?: IMappedValuePair[];
  versionNumber: string;
}

/**
 * Estructura simplificada para un par clave-valor mapeado.
 */
export interface IMappedValuePair {
  name: string;
  value: string;
  execOrder: string;
  reverseAssignment: "YES" | "NO";
}


--------------------------------------------------------------------------------

// src/interfaces/powermart.interface.ts

// src/interfaces/powermart.interface.ts
import type { IMapping, ITableAttribute } from "./mapping.interface";
import type { ISession } from "./sessiones.interface";
import type { IConfig, ITask, IWorkflow } from "./workflow.interface";

/**
 * Representa el nodo ra√≠z del documento XML de PowerCenter.
 * Los atributos se fusionan como propiedades directas debido a `mergeAttrs: true`.
 */
export interface IPowerMart {
  CREATION_DATE: string;
  REPOSITORY_VERSION: string;
  REPOSITORY: IRepository;
}

/**
 * Contiene la informaci√≥n del repositorio y la carpeta principal.
 */
export interface IRepository {
  NAME: string;
  VERSION: string;
  CODEPAGE: string;
  DATABASETYPE: string;
  FOLDER: IFolder; // Asumiendo una sola carpeta principal por repositorio en este XML
}

/**
 * El contenedor principal para todos los objetos de ETL como
 * fuentes, destinos, mapeos, sesiones y workflows.
 */
export interface IFolder {
  NAME: string;
  GROUP?: string; // Presente pero vac√≠o en el ejemplo
  OWNER: string;
  SHARED: "SHARED" | "NOTSHARED";
  DESCRIPTION?: string;
  PERMISSIONS?: string; // Ejemplo: "rwx---r--"
  UUID?: string;
  SOURCE?: ISource[];
  TARGET?: ITarget[];
  MAPPING?: IMapping[];
  SESSION?: ISession[];
  WORKFLOW?: IWorkflow; // Asumiendo un √∫nico workflow por archivo XML en este contexto
  CONFIG?: IConfig[];
  TASK?: ITask[]; // Tareas reutilizables definidas directamente en la carpeta
  ERPINFO?: object; // Etiqueta vac√≠a en el XML de ejemplo
}

/**
 * Interfaz gen√©rica para un campo (columna) en una fuente o destino.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IField {
  NAME: string;
  DATATYPE: string; // Ej. "date", "varchar2", "number(p,s)"
  KEYTYPE: "PRIMARY KEY" | "NOT A KEY" | "PRIMARY FOREIGN KEY" | "FOREIGN KEY";
  NULLABLE: "NULL" | "NOTNULL";
  PRECISION: string; // Ej. "19", "200"
  SCALE: string; // Ej. "0", "9"
  DESCRIPTION?: string;
  BUSINESSNAME?: string;
  FIELDNUMBER: string;
  PICTURETEXT?: string;
  // Atributos espec√≠ficos para SOURCEFIELD (se hacen opcionales para reutilizar en TARGETFIELD)
  FIELDPROPERTY?: string; // Ej. "0"
  FIELDTYPE?: string; // Ej. "ELEMITEM"
  HIDDEN?: "YES" | "NO"; // Ej. "NO"
  LENGTH?: string; // Ej. "19", "0", "10"
  LEVEL?: string; // Ej. "0"
  OCCURS?: string; // Ej. "0"
  OFFSET?: string; // Ej. "0", "19"
  PHYSICALLENGTH?: string; // Ej. "19", "200"
  PHYSICALOFFSET?: string; // Ej. "0", "19"
  USAGE_FLAGS?: string; // Ej. ""
}

/**
 * Representa una definici√≥n de fuente de datos (Source Definition).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISource {
  NAME: string;
  DATABASETYPE: string;
  DBDNAME: string;
  OWNERNAME: string;
  OBJECTVERSION: string;
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  BUSINESSNAME?: string; // Presente pero vac√≠o en el ejemplo
  SOURCEFIELD?: IField[];
  FLATFILE?: IFlatFile; // Atributos espec√≠ficos si es un archivo plano
  TABLEATTRIBUTE?: ITableAttribute[]; // Las fuentes tambi√©n pueden tener atributos, ej. `Base Table Name`
}

/**
 * Representa una definici√≥n de destino de datos (Target Definition).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITarget {
  NAME: string;
  DATABASETYPE: string;
  OBJECTVERSION: string;
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  BUSINESSNAME?: string; // Presente pero vac√≠o en el ejemplo
  CONSTRAINT?: string; // Presente pero vac√≠o en el ejemplo
  TABLEOPTIONS?: string; // Presente pero vac√≠o en el ejemplo
  TARGETFIELD?: IField[];
  TABLEATTRIBUTE?: ITableAttribute[]; // Los destinos pueden tener atributos como Pre/Post SQL
}

/**
 * Propiedades espec√≠ficas para fuentes de tipo Flat File.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IFlatFile {
  CODEPAGE: string; // Ej. "UTF-8"
  CONSECDELIMITERSASONE: "YES" | "NO"; // Ej. "NO"
  DELIMITED: "YES" | "NO"; // Ej. "YES"
  DELIMITERS: string; // Ej. ","
  ESCAPE_CHARACTER: string; // Ej. ""
  KEEPESCAPECHAR: "YES" | "NO"; // Ej. "NO"
  LINESEQUENTIAL: "YES" | "NO"; // Ej. "NO"
  MULTIDELIMITERSASAND: "YES" | "NO"; // Ej. "YES"
  NULLCHARTYPE: string; // Ej. "ASCII"
  NULL_CHARACTER: string; // Ej. "*"
  PADBYTES: string; // Ej. "1"
  QUOTE_CHARACTER: "SINGLE" | "DOUBLE" | "NONE"; // Ej. "DOUBLE"
  REPEATABLE: "YES" | "NO"; // Ej. "NO"
  ROWDELIMITER: string; // Ej. "10"
  SHIFTSENSITIVEDATA: "YES" | "NO"; // Ej. "NO"
  SKIPROWS: string; // Ej. "1"
  STRIPTRAILINGBLANKS: "YES" | "NO"; // Ej. "NO"
}


--------------------------------------------------------------------------------

// src/interfaces/sessiones.interface.ts

// src/interfaces/sessiones.interface.ts
import type { ITableAttribute } from "./mapping.interface";

/**
 * Representa una sesi√≥n, que es la instancia ejecutable de un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISession {
  NAME: string;
  MAPPINGNAME: string;
  ISVALID: "YES" | "NO";
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  SORTORDER?: string; // Ej. "Binary"
  SESSTRANSFORMATIONINST?: ISessTransformationInst[];
  SESSIONEXTENSION?: ISessionExtension[];
  ATTRIBUTE?: ITableAttribute[];
  CONFIGREFERENCE: IConfigReference;
  SESSIONCOMPONENT?: ISessionComponent[]; // Componentes reutilizables (ej. Email_Failed)
}

/**
 * Instancia de una transformaci√≥n dentro de una sesi√≥n, define propiedades
 * como el particionamiento.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISessTransformationInst {
  SINSTANCENAME: string;
  TRANSFORMATIONNAME: string;
  TRANSFORMATIONTYPE: string;
  PIPELINE: string;
  STAGE: string;
  ISREPARTITIONPOINT: "YES" | "NO";
  PARTITIONTYPE: "PASS THROUGH" | "HASH AUTO KEYS" | "ROUND ROBIN" | string;
  DESCRIPTION?: string; // En algunos casos, la instancia de transformaci√≥n tiene una descripci√≥n
  // Un <SESSTRANSFORMATIONINST> puede contener <ATTRIBUTE> (para atributos de partici√≥n)
  ATTRIBUTE?: ITableAttribute[];
  // Puede contener tambi√©n una etiqueta <PARTITION> con sus propios atributos.
  PARTITION?: {
    NAME: string;
    DESCRIPTION?: string;
  }[];
}

/**
 * Define configuraciones espec√≠ficas para conexiones de la sesi√≥n
 * (lectores, escritores, lookups).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISessionExtension {
  NAME: string; // Ej. "Relational Writer", "Relational Reader", "Relational Lookup"
  SINSTANCENAME: string;
  SUBTYPE: string; // Ej. "Relational Writer", "Relational Lookup"
  TRANSFORMATIONTYPE: string; // Ej. "Target Definition", "Source Qualifier", "Lookup Procedure"
  TYPE: "READER" | "WRITER" | "LOOKUPEXTENSION";
  // Atributos espec√≠ficos para extensiones de Source Qualifier
  DSQINSTNAME?: string;
  DSQINSTTYPE?: string;
  CONNECTIONREFERENCE?: IConnectionReference; // Esto es una etiqueta hija
  ATTRIBUTE?: ITableAttribute[]; // Esto es una etiqueta hija
}

/**
 * Referencia a una conexi√≥n de base de datos o de otro tipo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConnectionReference {
  CNXREFNAME: string;
  CONNECTIONTYPE: "Relational" | "Application" | string;
  VARIABLE: string;
  CONNECTIONNAME?: string;
  CONNECTIONNUMBER?: string;
  CONNECTIONSUBTYPE?: string;
}

/**
 * Referencia a un objeto de configuraci√≥n.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConfigReference {
  TYPE: string;
  REFOBJECTNAME: string;
}

/**
 * Referencia a un componente de sesi√≥n reutilizable (ej. una tarea de Email para notificaci√≥n de fallo).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISessionComponent {
  REFOBJECTNAME: string;
  REUSABLE: "YES" | "NO";
  TYPE: "Failure Email" | string;
}


--------------------------------------------------------------------------------

// src/interfaces/workflow.interface.ts

// src/interfaces/workflow.interface.ts
import type { ITableAttribute } from "./mapping.interface";

/**
 * Representa el flujo de trabajo (Workflow) que orquesta la ejecuci√≥n de tareas.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IWorkflow {
  NAME: string;
  ISVALID: "YES" | "NO";
  ISENABLED: "YES" | "NO";
  VERSIONNUMBER: string;
  SERVERNAME: string;
  SERVER_DOMAINNAME: string;
  DESCRIPTION?: string;
  REUSABLE_SCHEDULER?: "NO";
  SCHEDULERNAME?: string; // Ejemplo: "Scheduler"
  SUSPEND_ON_ERROR?: "YES" | "NO";
  TASKS_MUST_RUN_ON_SERVER?: "YES" | "NO";
  SCHEDULER: IScheduler;
  TASK?: ITask[]; // Tareas reutilizables definidas directamente en la carpeta
  TASKINSTANCE?: ITaskInstance[];
  WORKFLOWLINK?: IWorkflowLink[];
  WORKFLOWVARIABLE?: IWorkflowVariable[];
  ATTRIBUTE?: ITableAttribute[]; // Atributos a nivel de workflow como el Parameter Filename
}

/**
 * Una tarea reutilizable definida en la carpeta (ej. Email, Command).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITask {
  NAME: string;
  TYPE: "Email" | "Command" | "Decision" | "Assignment" | "Start";
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  ATTRIBUTE?: ITableAttribute[];
  VALUEPAIR?: IValuePair[]; // Para tareas de Command, Decision, Assignment
}

/**
 * Representa un par clave-valor, a menudo utilizado en tareas de comando para par√°metros.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IValuePair {
  EXECORDER: string;
  NAME: string;
  REVERSEASSIGNMENT: "YES" | "NO";
  VALUE: string;
}

/**
 * Instancia de una tarea o sesi√≥n dentro del flujo de trabajo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITaskInstance {
  NAME: string;
  TASKNAME: string;
  TASKTYPE: "Start" | "Session" | "Command" | "Decision" | "Assignment";
  ISENABLED: "YES" | "NO";
  // Atributos adicionales presentes en TASKINSTANCE en el XML:
  DESCRIPTION?: string;
  REUSABLE?: "YES" | "NO";
  FAIL_PARENT_IF_INSTANCE_DID_NOT_RUN?: "NO";
  FAIL_PARENT_IF_INSTANCE_FAILS?: "NO";
  TREAT_INPUTLINK_AS_AND?: "YES";
  // Espec√≠ficos para tareas Decision
  "Decision Name"?: string; // Nombre del atributo en el XML
  ATTRIBUTE?: ITableAttribute[]; // Las instancias de tareas pueden tener atributos
  // Aunque el ejemplo no las muestra, una instancia de tarea podr√≠a tener SessionExtension
  // si es una sesi√≥n con overrides en l√≠nea. De momento no se a√±ade aqu√≠.
}

/**
 * Define un enlace de ejecuci√≥n entre dos instancias de tareas.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IWorkflowLink {
  FROMTASK: string;
  TOTASK: string;
  CONDITION?: string; // Condici√≥n para el enlace
}

/**
 * Define una variable a nivel de workflow.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IWorkflowVariable {
  NAME: string;
  DATATYPE: string;
  USERDEFINED: "YES" | "NO";
  ISNULL: "YES" | "NO";
  ISPERSISTENT: "YES" | "NO";
  DEFAULTVALUE?: string;
  DESCRIPTION?: string;
}

/**
 * Define la configuraci√≥n de scheduling del workflow.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IScheduler {
  NAME: string;
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  SCHEDULEINFO: IScheduleInfo;
}

/**
 * Detalles sobre el schedule.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IScheduleInfo {
  SCHEDULETYPE: "ONDEMAND" | "RUNONCE" | "RUNONSERVERINIT" | string;
}

/**
 * Configuraci√≥n por defecto de la sesi√≥n.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConfig {
  NAME: string;
  ISDEFAULT: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  ATTRIBUTE?: ITableAttribute[];
}


--------------------------------------------------------------------------------

// src/lib/extractor.ts

import * as fs from "fs/promises";
import * as path from "path";
import { parseStringPromise } from "xml2js";
import type {
  IExtractionResult,
  IFlatExtractionData,
  IMappedTaskInstance,
} from "../interfaces/index";

import {
  ensureArray,
  mapConfig,
  mapMapping,
  mapSession,
  mapSource,
  mapTarget,
  mapTask,
  mapWorkflow,
} from "./mappingHelpers.ts";

const xmlInputDir = path.join(process.cwd(), "xml_inputs");
const outputJsonFilePath = path.join(process.cwd(), "public/extraction.json");

/**
 * Funci√≥n principal as√≠ncrona que orquesta el proceso de extracci√≥n.
 * Lee, procesa y combina m√∫ltiples archivos XML en un √∫nico JSON.
 */
async function runExtraction() {
  try {
    // 1. Asegurarse de que el directorio de salida exista
    await fs.mkdir(path.dirname(outputJsonFilePath), { recursive: true });

    // 2. Leer todos los nombres de archivo del directorio de entrada
    const files = await fs.readdir(xmlInputDir);
    const xmlFiles = files.filter(
      (file) => path.extname(file).toLowerCase() === ".xml"
    );

    if (xmlFiles.length === 0) {
      console.log(
        `No se encontraron archivos XML en el directorio: ${xmlInputDir}`
      );
      // Crear un archivo JSON vac√≠o para evitar que la aplicaci√≥n falle
      await fs.writeFile(
        outputJsonFilePath,
        JSON.stringify(
          {
            repositoryName: "N/A",
            folderName: "N/A",
            summary: {
              totalWorkflows: 0,
              totalSessions: 0,
              totalMappings: 0,
              totalSources: 0,
              totalTargets: 0,
              totalTransformations: 0,
            },
            mappings: [],
            workflows: [],
            sources: [],
            targets: [],
            sessions: [],
            configs: [],
            reusableTasks: [],
            allTasksInstances: [],
          },
          null,
          2
        )
      );
      console.log(
        `Archivo 'extraction.json' vac√≠o creado en ${outputJsonFilePath}`
      );
      return;
    }
    console.log(`Archivos XML encontrados: ${xmlFiles.join(", ")}`);

    // 3. Procesar cada archivo XML en paralelo para mayor eficiencia
    const allResults = await Promise.all(
      xmlFiles.map(async (fileName) => {
        const filePath = path.join(xmlInputDir, fileName);
        const xmlData = await fs.readFile(filePath, "utf8");
        const result: IExtractionResult = await parseStringPromise(xmlData, {
          explicitArray: false,
          mergeAttrs: true,
        });
        return result;
      })
    );

    // 4. Inicializar la estructura de datos final
    const finalExtraction: IFlatExtractionData = {
      repositoryName: "",
      folderName: "",
      summary: {
        totalWorkflows: 0,
        totalSessions: 0,
        totalMappings: 0,
        totalSources: 0,
        totalTargets: 0,
        totalTransformations: 0,
      },
      mappings: [],
      workflows: [],
      sources: [],
      targets: [],
      sessions: [],
      configs: [],
      reusableTasks: [],
      allTasksInstances: [],
    };

    // 5. Iterar y fusionar los resultados
    allResults.forEach((result, index) => {
      const powerMart = result.POWERMART;
      const folder = powerMart.REPOSITORY.FOLDER;

      if (index === 0) {
        finalExtraction.repositoryName = powerMart.REPOSITORY.NAME;
        finalExtraction.folderName = folder.NAME;
      }

      finalExtraction.sources.push(
        ...ensureArray(folder.SOURCE).map(mapSource)
      );
      finalExtraction.targets.push(
        ...ensureArray(folder.TARGET).map(mapTarget)
      );
      finalExtraction.mappings.push(
        ...ensureArray(folder.MAPPING).map(mapMapping)
      );
      finalExtraction.sessions.push(
        ...ensureArray(folder.SESSION).map(mapSession)
      );
      finalExtraction.workflows.push(
        ...ensureArray(folder.WORKFLOW).map(mapWorkflow)
      );
      finalExtraction.configs.push(
        ...ensureArray(folder.CONFIG).map(mapConfig)
      );
      finalExtraction.reusableTasks.push(
        ...ensureArray(folder.TASK).map(mapTask)
      );
    });

    // 6. Recalcular el resumen final
    finalExtraction.summary = {
      totalWorkflows: finalExtraction.workflows.length,
      totalSessions: finalExtraction.sessions.length,
      totalMappings: finalExtraction.mappings.length,
      totalSources: finalExtraction.sources.length,
      totalTargets: finalExtraction.targets.length,
      totalTransformations: finalExtraction.mappings.reduce(
        (acc, m) => acc + (m.transformations?.length || 0),
        0
      ),
    };

    // 7. Consolidar todas las instancias de tareas
    let allTasksInstances: IMappedTaskInstance[] = [];
    finalExtraction.workflows.forEach((wf) => {
      allTasksInstances.push(...wf.tasks);
    });
    finalExtraction.allTasksInstances = allTasksInstances;

    // 8. Guardar el resultado
    await fs.writeFile(
      outputJsonFilePath,
      JSON.stringify(finalExtraction, null, 2)
    );

    console.log(
      `\nExtracci√≥n completada. Datos combinados guardados en ${outputJsonFilePath}`
    );
    console.log("Resumen final:", finalExtraction.summary);
  } catch (err) {
    if (
      (err as NodeJS.ErrnoException).code === "ENOENT" &&
      (err as NodeJS.ErrnoException).path === xmlInputDir
    ) {
      console.error(
        `Error: El directorio de entrada '${xmlInputDir}' no existe. Por favor, cr√©alo y a√±ade tus archivos XML.`
      );
    } else {
      console.error("Ocurri√≥ un error durante el proceso de extracci√≥n:", err);
    }
  }
}

runExtraction();


--------------------------------------------------------------------------------

// src/lib/mappingHelpers.ts

// src/lib/mappingHelpers.ts

// Importa todas las interfaces necesarias desde el directorio de interfaces.
// Estas interfaces definen la forma de los datos tanto del XML original como de la estructura mapeada.
import type {
  IConfig,
  IConnectionReference,
  IConnector,
  IField,
  IInstance,
  IMappedAttribute,
  IMappedConfig,
  IMappedConnectionReference,
  IMappedConnector,
  IMappedField,
  IMappedInstance,
  IMappedMapping,
  IMappedMappingVariable,
  IMappedMetadataExtension,
  IMappedScheduler,
  IMappedSession,
  IMappedSessionComponent,
  IMappedSessionExtension,
  IMappedSessTransformationInst,
  IMappedSource,
  IMappedTarget,
  IMappedTargetLoadOrder,
  IMappedTask,
  IMappedTaskInstance,
  IMappedTransformation,
  IMappedTransformField,
  IMappedValuePair,
  IMappedWorkflow,
  IMappedWorkflowLink,
  IMappedWorkflowVariable,
  IMapping,
  IMappingVariable,
  IMetaDataExtension,
  IScheduler,
  ISession,
  ISessionComponent,
  ISessionExtension,
  ISessTransformationInst,
  ISource,
  ITableAttribute,
  ITarget,
  ITargetLoadOrder,
  ITask,
  ITaskInstance,
  ITransformation,
  ITransformField,
  IValuePair,
  IWorkflow,
  IWorkflowLink,
  IWorkflowVariable,
} from "../interfaces/index";

/**
 * Helper para asegurar que un elemento siempre se trate como un array.
 * @param item El elemento a normalizar.
 * @returns Un array de elementos.
 */
export function ensureArray<T>(item: T | T[] | undefined | null): T[] {
  if (item === undefined || item === null) {
    return [];
  }
  return Array.isArray(item) ? item : [item];
}

export function mapAttribute(attr: ITableAttribute): IMappedAttribute {
  return {
    name: attr.NAME,
    value: attr.VALUE,
  };
}

export function mapField(field: IField): IMappedField {
  return {
    name: field.NAME,
    dataType: field.DATATYPE,
    keyType: field.KEYTYPE,
    nullable: field.NULLABLE,
    precision: field.PRECISION,
    scale: field.SCALE,
    description: field.DESCRIPTION,
    length: field.LENGTH,
    physicalLength: field.PHYSICALLENGTH,
    fieldProperty: field.FIELDPROPERTY,
    fieldType: field.FIELDTYPE,
    hidden: field.HIDDEN,
    level: field.LEVEL,
    occurs: field.OCCURS,
    offset: field.OFFSET,
    usage_flags: field.USAGE_FLAGS,
  };
}

export function mapSource(source: ISource): IMappedSource {
  return {
    name: source.NAME,
    databaseType: source.DATABASETYPE,
    ownerName: source.OWNERNAME,
    description: source.DESCRIPTION,
    fields: ensureArray(source.SOURCEFIELD).map(mapField),
    isFlatFile: !!source.FLATFILE,
    attributes: ensureArray(source.TABLEATTRIBUTE).map(mapAttribute),
  };
}

export function mapTarget(target: ITarget): IMappedTarget {
  return {
    name: target.NAME,
    databaseType: target.DATABASETYPE,
    description: target.DESCRIPTION,
    fields: ensureArray(target.TARGETFIELD).map(mapField),
    attributes: ensureArray(target.TABLEATTRIBUTE).map(mapAttribute),
  };
}

export function mapTransformField(
  field: ITransformField
): IMappedTransformField {
  return {
    name: field.NAME,
    portType: field.PORTTYPE,
    dataType: field.DATATYPE,
    precision: field.PRECISION,
    scale: field.SCALE,
    expression: field.EXPRESSION,
    expressionType: field.EXPRESSIONTYPE,
    description: field.DESCRIPTION,
    isSortKey: field.ISSORTKEY,
    sortDirection: field.SORTDIRECTION,
    defaultValue: field.DEFAULTVALUE,
    pictureText: field.PICTURETEXT,
  };
}

export function mapMetadataExtension(
  ext: IMetaDataExtension
): IMappedMetadataExtension {
  return {
    name: ext.NAME,
    value: ext.VALUE,
    dataType: ext.DATATYPE,
    description: ext.DESCRIPTION,
    vendorName: ext.VENDORNAME,
    domainName: ext.DOMAINNAME,
    isClientEditable: ext.ISCLIENTEDITABLE,
    isClientVisible: ext.ISCLIENTVISIBLE,
    isReusable: ext.ISREUSABLE,
    isShareRead: ext.ISSHAREREAD,
    isShareWrite: ext.ISSHAREWRITE,
    maxLength: ext.MAXLENGTH,
  };
}

export function mapTransformation(
  trans: ITransformation
): IMappedTransformation {
  return {
    name: trans.NAME,
    type: trans.TYPE,
    description: trans.DESCRIPTION,
    reusable: trans.REUSABLE,
    fields: ensureArray(trans.TRANSFORMFIELD).map(mapTransformField),
    attributes: ensureArray(trans.TABLEATTRIBUTE).map(mapAttribute),
    metadataExtensions: ensureArray(trans.METADATAEXTENSION).map(
      mapMetadataExtension
    ),
  };
}

export function mapInstance(instance: IInstance): IMappedInstance {
  return {
    name: instance.NAME,
    type: instance.TYPE,
    transformationName: instance.TRANSFORMATION_NAME,
    transformationType: instance.TRANSFORMATION_TYPE,
    description: instance.DESCRIPTION,
    associatedSourceInstanceName: instance.ASSOCIATED_SOURCE_INSTANCE?.NAME,
    attributes: ensureArray(instance.TABLEATTRIBUTE).map(mapAttribute),
  };
}

export function mapConnector(connector: IConnector): IMappedConnector {
  return {
    fromField: connector.FROMFIELD,
    fromInstance: connector.FROMINSTANCE,
    fromInstanceType: connector.FROMINSTANCETYPE,
    toField: connector.TOFIELD,
    toInstance: connector.TOINSTANCE,
    toInstanceType: connector.TOINSTANCETYPE,
  };
}

export function mapTargetLoadOrder(
  tlo: ITargetLoadOrder
): IMappedTargetLoadOrder {
  return {
    order: tlo.ORDER,
    targetInstance: tlo.TARGETINSTANCE,
  };
}

export function mapMappingVariable(
  mv: IMappingVariable
): IMappedMappingVariable {
  return {
    name: mv.NAME,
    dataType: mv.DATATYPE,
    isParam: mv.ISPARAM,
    defaultValue: mv.DEFAULTVALUE,
    precision: mv.PRECISION,
    scale: mv.SCALE,
    isExpressionVariable: mv.ISEXPRESSIONVARIABLE,
    userDefined: mv.USERDEFINED,
    description: mv.DESCRIPTION,
  };
}

export function mapMapping(mapping: IMapping): IMappedMapping {
  return {
    name: mapping.NAME,
    isValid: mapping.ISVALID,
    description: mapping.DESCRIPTION,
    transformations: ensureArray(mapping.TRANSFORMATION).map(mapTransformation),
    instances: ensureArray(mapping.INSTANCE).map(mapInstance),
    connectors: ensureArray(mapping.CONNECTOR).map(mapConnector),
    targetLoadOrders: ensureArray(mapping.TARGETLOADORDER).map(
      mapTargetLoadOrder
    ),
    variables: ensureArray(mapping.MAPPINGVARIABLE).map(mapMappingVariable),
  };
}

export function mapValuePair(vp: IValuePair): IMappedValuePair {
  return {
    name: vp.NAME,
    value: vp.VALUE,
    execOrder: vp.EXECORDER,
    reverseAssignment: vp.REVERSEASSIGNMENT,
  };
}

export function mapTask(task: ITask): IMappedTask {
  return {
    name: task.NAME,
    type: task.TYPE,
    description: task.DESCRIPTION,
    reusable: task.REUSABLE,
    versionNumber: task.VERSIONNUMBER,
    attributes: ensureArray(task.ATTRIBUTE).map(mapAttribute),
    valuePairs: ensureArray(task.VALUEPAIR).map(mapValuePair),
  };
}

export function mapTaskInstance(taskInst: ITaskInstance): IMappedTaskInstance {
  return {
    name: taskInst.NAME,
    taskName: taskInst.TASKNAME,
    taskType: taskInst.TASKTYPE,
    isEnabled: taskInst.ISENABLED,
    failParentIfFails: taskInst.FAIL_PARENT_IF_INSTANCE_FAILS,
    failParentIfDidNotRun: taskInst.FAIL_PARENT_IF_INSTANCE_DID_NOT_RUN,
    treatInputLinkAsAnd: taskInst.TREAT_INPUTLINK_AS_AND,
    attributes: ensureArray(taskInst.ATTRIBUTE).map(mapAttribute),
    description: taskInst.DESCRIPTION,
    reusable: taskInst.REUSABLE,
    decisionName: taskInst["Decision Name"],
  };
}

export function mapWorkflowLink(link: IWorkflowLink): IMappedWorkflowLink {
  return {
    fromTask: link.FROMTASK,
    toTask: link.TOTASK,
    condition: link.CONDITION,
  };
}

export function mapWorkflowVariable(
  wfVar: IWorkflowVariable
): IMappedWorkflowVariable {
  return {
    name: wfVar.NAME,
    dataType: wfVar.DATATYPE,
    userDefined: wfVar.USERDEFINED,
    defaultValue: wfVar.DEFAULTVALUE,
    isPersistent: wfVar.ISPERSISTENT,
    description: wfVar.DESCRIPTION,
    isNull: wfVar.ISNULL,
  };
}

export function mapScheduler(scheduler: IScheduler): IMappedScheduler {
  return {
    name: scheduler.NAME,
    scheduleType: scheduler.SCHEDULEINFO?.SCHEDULETYPE || "UNKNOWN",
    description: scheduler.DESCRIPTION,
  };
}

export function mapWorkflow(workflow: IWorkflow): IMappedWorkflow {
  return {
    name: workflow.NAME,
    isValid: workflow.ISVALID,
    isEnabled: workflow.ISENABLED,
    description: workflow.DESCRIPTION,
    serverName: workflow.SERVERNAME,
    tasks: ensureArray(workflow.TASKINSTANCE).map(mapTaskInstance),
    links: ensureArray(workflow.WORKFLOWLINK).map(mapWorkflowLink),
    variables: ensureArray(workflow.WORKFLOWVARIABLE).map(mapWorkflowVariable),
    attributes: ensureArray(workflow.ATTRIBUTE).map(mapAttribute),
    scheduler: mapScheduler(workflow.SCHEDULER),
  };
}

export function mapSessTransformationInst(
  stInst: ISessTransformationInst
): IMappedSessTransformationInst {
  return {
    instanceName: stInst.SINSTANCENAME,
    transformationName: stInst.TRANSFORMATIONNAME,
    transformationType: stInst.TRANSFORMATIONTYPE,
    pipeline: stInst.PIPELINE,
    stage: stInst.STAGE,
    isRepartitionPoint: stInst.ISREPARTITIONPOINT,
    partitionType: stInst.PARTITIONTYPE,
    attributes: ensureArray(stInst.ATTRIBUTE).map(mapAttribute),
    partition: ensureArray(stInst.PARTITION).map((p) => ({
      name: p.NAME,
      description: p.DESCRIPTION,
    })),
  };
}

export function mapConnectionReference(
  connRef: IConnectionReference
): IMappedConnectionReference {
  return {
    name: connRef.CNXREFNAME,
    type: connRef.CONNECTIONTYPE,
    variable: connRef.VARIABLE,
    connectionName: connRef.CONNECTIONNAME,
    connectionNumber: connRef.CONNECTIONNUMBER,
    connectionSubtype: connRef.CONNECTIONSUBTYPE,
  };
}

export function mapSessionExtension(
  sessExt: ISessionExtension
): IMappedSessionExtension {
  return {
    name: sessExt.NAME,
    instanceName: sessExt.SINSTANCENAME,
    subType: sessExt.SUBTYPE,
    transformationType: sessExt.TRANSFORMATIONTYPE,
    type: sessExt.TYPE,
    connectionReference: sessExt.CONNECTIONREFERENCE
      ? mapConnectionReference(sessExt.CONNECTIONREFERENCE)
      : undefined,
    attributes: ensureArray(sessExt.ATTRIBUTE).map(mapAttribute),
    dsqInstanceName: sessExt.DSQINSTNAME,
    dsqInstanceType: sessExt.DSQINSTTYPE,
  };
}

export function mapSessionComponent(
  sessComp: ISessionComponent
): IMappedSessionComponent {
  return {
    refObjectName: sessComp.REFOBJECTNAME,
    reusable: sessComp.REUSABLE,
    type: sessComp.TYPE,
  };
}

export function mapSession(session: ISession): IMappedSession {
  return {
    name: session.NAME,
    mappingName: session.MAPPINGNAME,
    isValid: session.ISVALID,
    description: session.DESCRIPTION,
    reusable: session.REUSABLE,
    versionNumber: session.VERSIONNUMBER,
    sortOrder: session.SORTORDER,
    transformationInstances: ensureArray(session.SESSTRANSFORMATIONINST).map(
      mapSessTransformationInst
    ),
    sessionExtensions: ensureArray(session.SESSIONEXTENSION).map(
      mapSessionExtension
    ),
    attributes: ensureArray(session.ATTRIBUTE).map(mapAttribute),
    configReferenceName: session.CONFIGREFERENCE?.REFOBJECTNAME || "UNKNOWN",
    sessionComponents: ensureArray(session.SESSIONCOMPONENT).map(
      mapSessionComponent
    ),
  };
}

export function mapConfig(config: IConfig): IMappedConfig {
  return {
    name: config.NAME,
    isDefault: config.ISDEFAULT,
    description: config.DESCRIPTION,
    versionNumber: config.VERSIONNUMBER,
    attributes: ensureArray(config.ATTRIBUTE).map(mapAttribute),
  };
}


--------------------------------------------------------------------------------

// src/pages/Dashboard.tsx

// src/pages/Dashboard.tsx
import { DataTable } from "../components/common/DataTable";
import { KPICard } from "../components/dashboard/KPICard";
import MappingTypeChart from "../components/dashboard/MappingTypeChart";
import MappingGraph from "../components/mappings/MappingGraph";
import { useExtractionData } from "../hooks/useExtractionData";

export default function Dashboard() {
  const { data, loading, error } = useExtractionData();

  const mappings = data?.mappings ?? [];
  const s = data?.summary;

  const kpis = {
    workflows: s?.totalWorkflows ?? 0,
    sessions: s?.totalSessions ?? 0,
    mappings: s?.totalMappings ?? mappings.length,
    sources: s?.totalSources ?? 0,
    targets: s?.totalTargets ?? 0,
  };

  const mappingColumns = [
    { header: "Mapping", accessorKey: "name" },
    {
      header: "V√°lido",
      cell: ({ row }: any) => (row.original?.isValid === "YES" ? "S√≠" : "No"),
    },
    {
      header: "#Transf.",
      cell: ({ row }: any) => row.original?.transformations?.length ?? 0,
    },
    {
      header: "#Instancias",
      cell: ({ row }: any) => row.original?.instances?.length ?? 0,
    },
  ];

  return (
    <div className="mx-auto max-w-[1400px] space-y-6 p-6">
      <h1 className="text-2xl font-semibold text-gray-900">Dashboard IPC</h1>
      {loading && <div className="text-gray-600">Cargando extracci√≥n‚Ä¶</div>}
      {error && <div className="text-red-600">Error: {error}</div>}

      {!loading && !error && (
        <>
          {/* KPIs */}
          <div className="grid grid-cols-2 gap-4 md:grid-cols-5">
            <KPICard label="Workflows" value={kpis.workflows} />
            <KPICard label="Sessions" value={kpis.sessions} />
            <KPICard label="Mappings" value={kpis.mappings} />
            <KPICard label="Sources" value={kpis.sources} />
            <KPICard label="Targets" value={kpis.targets} />
          </div>

          {/* Distribuci√≥n por tipo de transformaci√≥n */}
          <section className="space-y-3">
            <h2 className="text-lg font-medium">
              Distribuci√≥n de Transformations
            </h2>
            <MappingTypeChart mappings={mappings as any} />
          </section>

          {/* Tabla comparativa de Mappings */}
          <section className="space-y-3">
            <h2 className="text-lg font-medium">Mappings</h2>
            <DataTable
              data={mappings as any}
              columns={mappingColumns as any}
              virtualized
              height={420}
            />
          </section>

          {/* Grafo de un Mapping (ejemplo: el primero) */}
          {mappings[0] && (
            <section className="space-y-3">
              <div className="flex items-center justify-between">
                <h2 className="text-lg font-medium">
                  Mapping: {mappings[0].name}
                </h2>
                <span className="text-sm text-gray-500">
                  (demo con el primer mapping)
                </span>
              </div>
              <MappingGraph mapping={mappings[0] as any} />
            </section>
          )}
        </>
      )}
    </div>
  );
}


--------------------------------------------------------------------------------

// src/pages/Details.tsx

import { useNavigate, useParams } from "react-router-dom";
import { useAppData } from "../components/layout/MainLayout";
import { Loader } from "../components/ui/Loader";
import type {
  IMappedMapping,
  IMappedSession,
  IMappedSource,
  IMappedTarget,
  IMappedWorkflow,
} from "../interfaces";

const Details = () => {
  const { objectType, objectId } = useParams<{
    objectType: string;
    objectId: string;
  }>();
  const navigate = useNavigate();
  const { data } = useAppData();

  if (!data) return <Loader />;

  // Find the object based on type and id
  let object:
    | IMappedMapping
    | IMappedWorkflow
    | IMappedSession
    | IMappedSource
    | IMappedTarget
    | null = null;
  let dependencies: string[] = [];

  switch (objectType) {
    case "mappings":
      object = data.mappings.find((m) => m.name === objectId) || null;
      if (object) {
        // Find dependencies: sources, targets, transformations
        const mapping = object as IMappedMapping;
        dependencies = [
          ...mapping.instances
            .filter((i) => i.type === "SOURCE")
            .map((i) => `Source: ${i.transformationName}`),
          ...mapping.instances
            .filter((i) => i.type === "TARGET")
            .map((i) => `Target: ${i.transformationName}`),
          ...mapping.transformations.map(
            (t) => `Transformation: ${t.name} (${t.type})`
          ),
        ];
      }
      break;
    case "workflows":
      object = data.workflows.find((w) => w.name === objectId) || null;
      if (object) {
        const workflow = object as IMappedWorkflow;
        dependencies = workflow.tasks.map(
          (t) => `Task: ${t.name} (${t.taskType})`
        );
      }
      break;
    case "sessions":
      object = data.sessions.find((s) => s.name === objectId) || null;
      if (object) {
        const session = object as IMappedSession;
        dependencies = [`Mapping: ${session.mappingName}`];
      }
      break;
    case "sources":
      object = data.sources.find((s) => s.name === objectId) || null;
      break;
    case "targets":
      object = data.targets.find((t) => t.name === objectId) || null;
      break;
    default:
      object = null;
  }

  if (!object) {
    return (
      <div className="p-6">
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <h2 className="text-xl font-semibold text-red-800 mb-2">
            Object Not Found
          </h2>
          <p className="text-red-600">
            The {objectType} "{objectId}" could not be found.
          </p>
          <button
            onClick={() => navigate(-1)}
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
          >
            Go Back
          </button>
        </div>
      </div>
    );
  }

  const renderObjectDetails = () => {
    switch (objectType) {
      case "mappings":
        const mapping = object as IMappedMapping;

        // Categorize components
        const sources = mapping.instances.filter((i) => i.type === "SOURCE");
        console.log(sources)
        const targets = mapping.instances.filter((i) => i.type === "TARGET");
        const sourceQualifiers = mapping.transformations.filter(
          (t) => t.type === "Source Qualifier"
        );
        const otherTransformations = mapping.transformations.filter(
          (t) => t.type !== "Source Qualifier"
        );

        return (
          <>
            {/* Basic Information */}
            <div className="mb-6">
              <h3 className="text-lg font-semibold mb-2">Basic Information</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <p>
                    <strong>Name:</strong> {mapping.name}
                  </p>
                  <p>
                    <strong>Type:</strong> Mapping
                  </p>
                  <p>
                    <strong>Valid:</strong>{" "}
                    <span
                      className={
                        mapping.isValid === "YES"
                          ? "text-green-600"
                          : "text-red-600"
                      }
                    >
                      {mapping.isValid}
                    </span>
                  </p>
                  <p>
                    <strong>Description:</strong> {mapping.description || "N/A"}
                  </p>
                </div>
                <div className="space-y-2">
                  <p>
                    <strong>Total Transformations:</strong>{" "}
                    {mapping.transformations.length}
                  </p>
                  <p>
                    <strong>Total Instances:</strong> {mapping.instances.length}
                  </p>
                  <p>
                    <strong>Connectors:</strong> {mapping.connectors.length}
                  </p>
                  <p>
                    <strong>Variables:</strong> {mapping.variables.length}
                  </p>
                </div>
              </div>
            </div>

            {/* 4-Column Layout */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              {/* Column 1: Sources */}
              <div className="bg-green-50 p-4 rounded-lg">
                <h4 className="text-md font-semibold mb-3 text-blue-800">
                  Sources
                </h4>
                <div className="space-y-2">
                  {sources.length > 0 ? (
                    sources.map((source, index) => (
                      <div
                        key={index}
                        className="bg-white p-2 rounded text-sm border"
                      >
                        <div className="font-medium">
                          {source.transformationName}
                        </div>
                        <div className="text-gray-600 text-xs">
                          {source.transformationType}
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-gray-500 text-sm">No sources</p>
                  )}
                </div>
              </div>

              {/* Column 2: Source Qualifier */}
              <div className="bg-yellow-50 p-4 rounded-lg">
                <h4 className="text-md font-semibold mb-3 text-green-800">
                  Source Qualifier
                </h4>
                <div className="space-y-2">
                  {sourceQualifiers.length > 0 ? (
                    sourceQualifiers.map((sq, index) => (
                      <div
                        key={index}
                        className="bg-white p-2 rounded text-sm border"
                      >
                        <div className="font-medium">{sq.name}</div>
                        <div className="text-gray-600 text-xs">{sq.type}</div>

                        {sq.attributes.map((attr, i) => {
                          if (
                            (i === 3 && attr.value === "0") ||
                            (i === 4 && attr.value === "Normal") ||
                            (i === 5 && attr.value === "NO") ||
                            (i === 6 && attr.value === "NO") ||
                            (i === 9 && attr.value === "NO") ||
                            (i === 10 && attr.value === "Never") ||
                            !attr.value
                          ) {
                            return null;
                          }

                          return (
                            <div key={i}>
                              <div className="text-gray-600 text-xs">
                                {i} {attr.name}
                              </div>
                              <div className="text-gray-600 text-xs">
                                {attr.value}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    ))
                  ) : (
                    <p className="text-gray-500 text-sm">
                      No source qualifiers
                    </p>
                  )}
                </div>
              </div>

              {/* Column 3: Other Transformations */}
              <div className="bg-red-50 p-4 rounded-lg">
                <h4 className="text-md font-semibold mb-3 text-yellow-800">
                  Transformations
                </h4>
                <div className="space-y-2 overflow-y-auto">
                  {otherTransformations.length > 0 ? (
                    otherTransformations.map((trans, index) => (
                      <div
                        key={index}
                        className="bg-white p-2 rounded text-sm border"
                      >
                        <div className="font-medium">{trans.name}</div>
                        <div className="text-gray-600 text-xs">
                          {trans.type}
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-gray-500 text-sm">No transformations</p>
                  )}
                </div>
              </div>

              {/* Column 4: Targets */}
              <div className="bg-purple-50 p-4 rounded-lg">
                <h4 className="text-md font-semibold mb-3 text-red-800">
                  Targets
                </h4>
                <div className="space-y-2">
                  {targets.length > 0 ? (
                    targets.map((target, index) => (
                      <div
                        key={index}
                        className="bg-white p-2 rounded text-sm border"
                      >
                        <div className="font-medium">
                          {target.transformationName}
                        </div>
                        <div className="text-gray-600 text-xs">
                          {target.transformationType}
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-gray-500 text-sm">No targets</p>
                  )}
                </div>
              </div>
            </div>
          </>
        );
      case "workflows":
        const workflow = object as IMappedWorkflow;
        return (
          <>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h3 className="text-lg font-semibold mb-2">
                  Basic Information
                </h3>
                <div className="space-y-2">
                  <p>
                    <strong>Name:</strong> {workflow.name}
                  </p>
                  <p>
                    <strong>Type:</strong> Workflow
                  </p>
                  <p>
                    <strong>Valid:</strong>{" "}
                    <span
                      className={
                        workflow.isValid === "YES"
                          ? "text-green-600"
                          : "text-red-600"
                      }
                    >
                      {workflow.isValid}
                    </span>
                  </p>
                  <p>
                    <strong>Enabled:</strong>{" "}
                    <span
                      className={
                        workflow.isEnabled === "YES"
                          ? "text-green-600"
                          : "text-red-600"
                      }
                    >
                      {workflow.isEnabled}
                    </span>
                  </p>
                  <p>
                    <strong>Server:</strong> {workflow.serverName}
                  </p>
                  <p>
                    <strong>Description:</strong>{" "}
                    {workflow.description || "N/A"}
                  </p>
                </div>
              </div>
              <div>
                <h3 className="text-lg font-semibold mb-2">Statistics</h3>
                <div className="space-y-2">
                  <p>
                    <strong>Tasks:</strong> {workflow.tasks.length}
                  </p>
                  <p>
                    <strong>Links:</strong> {workflow.links.length}
                  </p>
                  <p>
                    <strong>Variables:</strong> {workflow.variables.length}
                  </p>
                </div>
              </div>
            </div>
            {dependencies.length > 0 && (
              <div className="mt-6">
                <h3 className="text-lg font-semibold mb-2">Tasks</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                  {dependencies.map((dep, index) => (
                    <div key={index} className="bg-gray-50 p-2 rounded text-sm">
                      {dep}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </>
        );
      case "sessions":
        const session = object as IMappedSession;
        return (
          <>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h3 className="text-lg font-semibold mb-2">
                  Basic Information
                </h3>
                <div className="space-y-2">
                  <p>
                    <strong>Name:</strong> {session.name}
                  </p>
                  <p>
                    <strong>Type:</strong> Session
                  </p>
                  <p>
                    <strong>Valid:</strong>{" "}
                    <span
                      className={
                        session.isValid === "YES"
                          ? "text-green-600"
                          : "text-red-600"
                      }
                    >
                      {session.isValid}
                    </span>
                  </p>
                  <p>
                    <strong>Reusable:</strong> {session.reusable}
                  </p>
                  <p>
                    <strong>Description:</strong> {session.description || "N/A"}
                  </p>
                </div>
              </div>
              <div>
                <h3 className="text-lg font-semibold mb-2">Configuration</h3>
                <div className="space-y-2">
                  <p>
                    <strong>Mapping:</strong> {session.mappingName}
                  </p>
                  <p>
                    <strong>Config Reference:</strong>{" "}
                    {session.configReferenceName}
                  </p>
                  <p>
                    <strong>Version:</strong> {session.versionNumber}
                  </p>
                </div>
              </div>
            </div>
            {dependencies.length > 0 && (
              <div className="mt-6">
                <h3 className="text-lg font-semibold mb-2">Dependencies</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                  {dependencies.map((dep, index) => (
                    <div key={index} className="bg-gray-50 p-2 rounded text-sm">
                      {dep}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </>
        );
      case "sources":
        const source = object as IMappedSource;
        return (
          <>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h3 className="text-lg font-semibold mb-2">
                  Basic Information
                </h3>
                <div className="space-y-2">
                  <p>
                    <strong>Name:</strong> {source.name}
                  </p>
                  <p>
                    <strong>Type:</strong> Source
                  </p>
                  <p>
                    <strong>Database Type:</strong> {source.databaseType}
                  </p>
                  <p>
                    <strong>Owner:</strong> {source.ownerName}
                  </p>
                  <p>
                    <strong>Description:</strong> {source.description || "N/A"}
                  </p>
                  <p>
                    <strong>Flat File:</strong>{" "}
                    {source.isFlatFile ? "Yes" : "No"}
                  </p>
                </div>
              </div>
              <div>
                <h3 className="text-lg font-semibold mb-2">Fields</h3>
                <p>
                  <strong>Total Fields:</strong> {source.fields.length}
                </p>
                <div className="mt-2 max-h-40 overflow-y-auto">
                  {source.fields.slice(0, 5).map((field, index) => (
                    <div
                      key={index}
                      className="text-sm bg-gray-50 p-1 rounded mb-1"
                    >
                      {field.name} ({field.dataType})
                    </div>
                  ))}
                  {source.fields.length > 5 && (
                    <p className="text-sm text-gray-500">
                      ... and {source.fields.length - 5} more fields
                    </p>
                  )}
                </div>
              </div>
            </div>
          </>
        );
      case "targets":
        const target = object as IMappedTarget;
        return (
          <>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h3 className="text-lg font-semibold mb-2">
                  Basic Information
                </h3>
                <div className="space-y-2">
                  <p>
                    <strong>Name:</strong> {target.name}
                  </p>
                  <p>
                    <strong>Type:</strong> Target
                  </p>
                  <p>
                    <strong>Database Type:</strong> {target.databaseType}
                  </p>
                  <p>
                    <strong>Description:</strong> {target.description || "N/A"}
                  </p>
                </div>
              </div>
              <div>
                <h3 className="text-lg font-semibold mb-2">Fields</h3>
                <p>
                  <strong>Total Fields:</strong> {target.fields.length}
                </p>
                <div className="mt-2 max-h-40 overflow-y-auto">
                  {target.fields.slice(0, 5).map((field, index) => (
                    <div
                      key={index}
                      className="text-sm bg-gray-50 p-1 rounded mb-1"
                    >
                      {field.name} ({field.dataType})
                    </div>
                  ))}
                  {target.fields.length > 5 && (
                    <p className="text-sm text-gray-500">
                      ... and {target.fields.length - 5} more fields
                    </p>
                  )}
                </div>
              </div>
            </div>
          </>
        );
      default:
        return <p>Unsupported object type</p>;
    }
  };

  return (
    <div className="p-6">
      <div className="mb-6">
        <button
          onClick={() => navigate(-1)}
          className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 mb-4"
        >
          ‚Üê Back
        </button>
        <h1 className="text-3xl font-bold capitalize">{objectType} Details</h1>
      </div>

      <div className="bg-white rounded-lg shadow-md p-6">
        {renderObjectDetails()}
      </div>
    </div>
  );
};

export default Details;


--------------------------------------------------------------------------------

// src/pages/Mappings.tsx

import { useAppData } from "../components/layout/MainLayout";
import { Card } from "../components/ui/Card";

const Mappings = () => {
  const { data, searchTerm } = useAppData();

  // Usamos optional chaining (?.) para evitar errores si data es null al inicio
  const filteredMappings = data?.mappings?.filter((mapping) =>
    mapping.name?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <h2 className="text-2xl font-bold mb-4">Mappings</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {filteredMappings && filteredMappings.length > 0 ? (
          filteredMappings.map((mapping) => (
            <Card
              key={mapping.name}
              title={mapping.name}
              titleClassName="text-blue-600"
              to={`/powercenter/mappings/${mapping.name}`}
            >
              <p>Estado: {mapping.isValid === "YES" ? "V√°lido" : "Inv√°lido"}</p>
              <p>Transformaciones: {mapping.transformations?.length || 0}</p>
            </Card>
          ))
        ) : (
          <p>No se encontraron mappings que coincidan con la b√∫squeda.</p>
        )}
      </div>
    </div>
  );
};

export default Mappings;


--------------------------------------------------------------------------------

// src/pages/NotFound.tsx

import { Link } from "react-router-dom";

const NotFound = () => {
  return (
    <div className="flex flex-col items-center justify-center h-screen bg-gray-100 text-center">
      <h1 className="text-6xl font-bold text-gray-800">404</h1>
      <h2 className="text-2xl font-semibold text-gray-600 mt-4">
        P√°gina no encontrada
      </h2>
      <p className="text-gray-500 mt-2">
        Lo sentimos, la p√°gina que est√°s buscando no existe.
      </p>
      <Link
        to="/"
        className="mt-6 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
      >
        Volver al Dashboard
      </Link>
    </div>
  );
};

export default NotFound;


--------------------------------------------------------------------------------

// src/pages/Sessions.tsx

import { useAppData } from "../components/layout/MainLayout";
import { Card } from "../components/ui/Card";

const Sessions = () => {
  const { data, searchTerm } = useAppData();

  const filteredSessions = data?.sessions?.filter((session) =>
    session.name?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <h2 className="text-2xl font-bold mb-4">Sessions</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {filteredSessions && filteredSessions.length > 0 ? (
          filteredSessions.map((session) => {
            const mappedMapping = data?.mappings.find(
              (m) => m.name === session.mappingName
            );

            const sourceNames =
              mappedMapping?.instances
                .filter((inst) => inst.type === "SOURCE")
                .map((inst) => inst.name) || [];
            const targetNames =
              mappedMapping?.instances
                .filter((inst) => inst.type === "TARGET")
                .map((inst) => inst.name) || [];
            const transformationNames =
              mappedMapping?.instances
                .filter((inst) => inst.type === "TRANSFORMATION")
                .map((inst) => `${inst.name} (${inst.transformationType})`) ||
              [];

            return (
              <Card
                key={session.name}
                title={session.name}
                titleClassName="text-teal-600"
                to={`/powercenter/sessions/${session.name}`}
              >
                <p>Mapping: {session.mappingName}</p>
                <p>Estado: {session.isValid}</p>
                <div className="mt-2 text-sm">
                  <p className="font-medium">
                    Sources ({sourceNames.length}):{" "}
                    {sourceNames.slice(0, 2).join(", ")}
                    {sourceNames.length > 2 ? "..." : ""}
                  </p>
                  <p className="font-medium">
                    Targets ({targetNames.length}):{" "}
                    {targetNames.slice(0, 2).join(", ")}
                    {targetNames.length > 2 ? "..." : ""}
                  </p>
                  <p className="font-medium">
                    Targets ({transformationNames.length}):{" "}
                    {transformationNames.slice(0, 2).join(", ")}
                    {transformationNames.length > 2 ? "..." : ""}
                  </p>
                </div>
              </Card>
            );
          })
        ) : (
          <p>No se encontraron sesiones que coincidan con la b√∫squeda.</p>
        )}
      </div>
    </div>
  );
};

export default Sessions;


--------------------------------------------------------------------------------

// src/pages/Sources.tsx

import { useAppData } from "../components/layout/MainLayout";
import { Card } from "../components/ui/Card";

const Sources = () => {
  const { data, searchTerm } = useAppData();

  const filteredSources = data?.sources?.filter((source) =>
    source.name?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <h2 className="text-2xl font-bold mb-4">Sources</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
        {filteredSources && filteredSources.length > 0 ? (
          filteredSources.map((source) => (
            <Card
              key={source.name}
              title={source.name}
              titleClassName="text-purple-600"
              to={`/powercenter/sources/${source.name}`}
            >
              <p>Tipo: {source.databaseType}</p>
              <div className="mt-2">
                <p className="font-medium">
                  Campos ({source.fields?.length || 0}):
                </p>
                <div className="max-h-20 overflow-y-auto text-sm">
                  {source.fields?.slice(0, 5).map((field, idx) => (
                    <div key={idx} className="flex justify-between">
                      <span>{field.name}</span>
                      <span className="text-gray-500">{field.dataType}</span>
                    </div>
                  ))}
                  {(source.fields?.length || 0) > 5 && (
                    <p className="text-gray-400">
                      ... y {source.fields.length - 5} m√°s
                    </p>
                  )}
                </div>
              </div>
            </Card>
          ))
        ) : (
          <p>No se encontraron sources que coincidan con la b√∫squeda.</p>
        )}
      </div>
    </div>
  );
};

export default Sources;


--------------------------------------------------------------------------------

// src/pages/Targets.tsx

import { useAppData } from "../components/layout/MainLayout";
import { Card } from "../components/ui/Card";

const Targets = () => {
  const { data, searchTerm } = useAppData();

  const filteredTargets = data?.targets?.filter((target) =>
    target.name?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <h2 className="text-2xl font-bold mb-4">Targets</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
        {filteredTargets && filteredTargets.length > 0 ? (
          filteredTargets.map((target) => (
            <Card
              key={target.name}
              title={target.name}
              titleClassName="text-red-600"
              to={`/powercenter/targets/${target.name}`}
            >
              <p>Tipo: {target.databaseType}</p>
              <div className="mt-2">
                <p className="font-medium">
                  Campos ({target.fields?.length || 0}):
                </p>
                <div className="max-h-20 overflow-y-auto text-sm">
                  {target.fields?.slice(0, 5).map((field, idx) => (
                    <div key={idx} className="flex justify-between">
                      <span>{field.name}</span>
                      <span className="text-gray-500">{field.dataType}</span>
                    </div>
                  ))}
                  {(target.fields?.length || 0) > 5 && (
                    <p className="text-gray-400">
                      ... y {target.fields.length - 5} m√°s
                    </p>
                  )}
                </div>
              </div>
            </Card>
          ))
        ) : (
          <p>No se encontraron targets que coincidan con la b√∫squeda.</p>
        )}
      </div>
    </div>
  );
};

export default Targets;


--------------------------------------------------------------------------------

// src/pages/Workflows.tsx

import { useAppData } from "../components/layout/MainLayout";
import { Card } from "../components/ui/Card";

const Workflows = () => {
  const { data, searchTerm } = useAppData();

  const filteredWorkflows = data?.workflows?.filter((workflow) =>
    workflow.name?.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <h2 className="text-2xl font-bold mb-4">Workflows</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {filteredWorkflows && filteredWorkflows.length > 0 ? (
          filteredWorkflows.map((workflow) => (
            <Card
              key={workflow.name}
              title={workflow.name}
              titleClassName="text-green-600"
              to={`/powercenter/workflows/${workflow.name}`}
            >
              <p>
                Estado: {workflow.isValid} / {workflow.isEnabled}
              </p>
              <p>Tareas: {workflow.tasks?.length || 0}</p>
              <p>Archivo de par√°metros: {workflow.attributes[0].value}</p>
            </Card>
          ))
        ) : (
          <p>No se encontraron workflows que coincidan con la b√∫squeda.</p>
        )}
      </div>
    </div>
  );
};

export default Workflows;


--------------------------------------------------------------------------------

// src/router/index.tsx

import { createBrowserRouter } from "react-router-dom";
import { MainLayout } from "../components/layout/MainLayout";

// Eager loading: Importa todos los componentes de p√°gina directamente
import Dashboard from "../pages/Dashboard";
import Details from "../pages/Details";
import Mappings from "../pages/Mappings";
import NotFound from "../pages/NotFound";
import Sessions from "../pages/Sessions";
import Sources from "../pages/Sources";
import Targets from "../pages/Targets";
import Workflows from "../pages/Workflows";

export const router = createBrowserRouter([
  {
    path: "/",
    element: <MainLayout />,
    children: [
      {
        index: true,
        element: <Dashboard />,
      },
      {
        path: "mappings",
        element: <Mappings />,
      },
      {
        path: "workflows",
        element: <Workflows />,
      },
      {
        path: "sessions",
        element: <Sessions />,
      },
      {
        path: "sources",
        element: <Sources />,
      },
      {
        path: "targets",
        element: <Targets />,
      },
      {
        path: "powercenter/:objectType/:objectId",
        element: <Details />,
      },
    ],
  },
  {
    path: "*",
    element: <NotFound />,
  },
]);


--------------------------------------------------------------------------------

// src/services/etlService.ts

import type { IFlatExtractionData } from "../interfaces";

export const getEtlData = async (): Promise<IFlatExtractionData> => {
  const response = await fetch("/extraction.json");
  if (!response.ok) {
    throw new Error("Network response was not ok");
  }
  return response.json();
};


--------------------------------------------------------------------------------

/* src/styles/index.css */

@import "tailwindcss";


--------------------------------------------------------------------------------

// src/types/extraction.ts

// src/types/extraction.ts
export type ExtractionSummary = {
  totalWorkflows: number;
  totalSessions: number;
  totalMappings: number;
  totalSources: number;
  totalTargets: number;
  totalTransformations: number;
};

export type MappingField = {
  name: string;
  portType?: string;
  dataType?: string;
  precision?: string;
  scale?: string;
  description?: string;
};

export type MappingTransformation = {
  name: string;
  type: string; // p.ej. "Expression", "Joiner", "Source Qualifier" ‚Ä¶
  description?: string;
  reusable?: string; // "YES" | "NO"
  fields?: MappingField[];
};

export type MappingInstance = {
  name: string;
  type: "SOURCE" | "TARGET" | "TRANSFORMATION";
  transformationName: string;
  transformationType: string; // p.ej. "Expression", "Source Definition", "Target Definition" ‚Ä¶
};

export type MappingConnector = {
  fromInstance: string;
  fromInstanceType: string;
  toInstance: string;
  toInstanceType: string;
  fromField?: string;
  toField?: string;
};

export type Mapping = {
  name: string;
  isValid?: string; // "YES" | "NO"
  description?: string;
  transformations?: MappingTransformation[];
  instances?: MappingInstance[];
  connectors?: MappingConnector[];
};

export type Extraction = {
  repositoryName?: string;
  folderName?: string;
  summary?: ExtractionSummary;
  mappings?: Mapping[];
  // workflows?: Workflow[]; // si existe, puedes tiparlo luego
};


--------------------------------------------------------------------------------

