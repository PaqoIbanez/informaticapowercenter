////////////////////////////////////////
///////****** informaticapowercenter ******///////
////////////////////////////////////////

////////  REACT  ////////
(Lenguajes: CSS, HTML, JSON, JavaScript, Markdown, TypeScript)

칈NDICE DE ARCHIVOS INCLUIDOS:
 - eslint.config.js
 - index.html
 - package.json
 - README.md
 - tsconfig.app.json
 - tsconfig.json
 - tsconfig.node.json
 - vite.config.ts
 - public/vite.svg
 - src/App.css
 - src/App.tsx
 - src/extractor.ts
 - src/index.css
 - src/main.tsx
 - src/vite-env.d.ts
 - src/assets/react.svg
 - src/interfaces/index.ts
 - src/interfaces/mapping.interface.ts
 - src/interfaces/multi-workflow.interface.ts
 - src/interfaces/powermart.interface.ts
 - src/interfaces/sessiones.interface.ts
 - src/interfaces/workflow.interface.ts

================================================================================

// eslint.config.js

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


--------------------------------------------------------------------------------

<!-- index.html -->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


--------------------------------------------------------------------------------

// package.json

{
  "name": "informaticapowercenter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.13",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "tailwindcss": "^4.1.13",
    "xml2js": "^0.6.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/react": "^19.1.13",
    "@types/react-dom": "^19.1.9",
    "@types/xml2js": "^0.4.14",
    "@vitejs/plugin-react": "^5.0.3",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.4.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.44.0",
    "vite": "^7.1.7"
  }
}


--------------------------------------------------------------------------------

** README.md **

# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```


--------------------------------------------------------------------------------

// tsconfig.app.json

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


--------------------------------------------------------------------------------

// tsconfig.json

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


--------------------------------------------------------------------------------

// tsconfig.node.json

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


--------------------------------------------------------------------------------

// vite.config.ts

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
})


--------------------------------------------------------------------------------

// public/vite.svg

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>


--------------------------------------------------------------------------------

/* src/App.css */

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


--------------------------------------------------------------------------------

// src/App.tsx

// src/App.tsx
import { useState, useEffect } from "react";
// Importa la nueva interfaz IFlatExtractionData y las interfaces mapeadas necesarias
import type { IFlatExtractionData } from "./interfaces/multi-workflow.interface"; 

function App() {
  const [activeSection, setActiveSection] = useState("dashboard");
  // Usa la nueva interfaz IFlatExtractionData
  const [data, setData] = useState<IFlatExtractionData | null>(null); 
  const [searchTerm, setSearchTerm] = useState("");

  useEffect(() => {
    // Cargar datos del JSON, asumiendo que "extraction.json" est치 en la carpeta 'public'
    fetch("/extraction.json") 
      .then((response) => response.json())
      .then((json: IFlatExtractionData) => setData(json)) // Casteo a IFlatExtractionData
      .catch((error) => console.error("Error loading data:", error));
  }, []);

  const sections = [
    { id: "dashboard", name: "Dashboard", icon: "游" },
    { id: "mappings", name: "Mappings", icon: "游댃" },
    { id: "workflows", name: "Workflows", icon: "丘뙖잺" },
    { id: "sessions", name: "Sessions", icon: "游늵" },
    { id: "sources", name: "Sources", icon: "游닌" },
    { id: "targets", name: "Targets", icon: "游닋" },
  ];

  const renderContent = () => {
    if (!data) return <div className="p-6">Cargando datos...</div>;

    switch (activeSection) {
      case "dashboard":
        return (
          <div className="p-6">
            <h2 className="text-2xl font-bold mb-4">Dashboard ETL</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <div className="bg-gradient-to-r from-blue-500 to-blue-600 text-white p-4 rounded-lg shadow-lg">
                <h3 className="text-lg font-semibold">Mappings</h3>
                <p>{data.summary.totalMappings} disponibles</p>
              </div>
              <div className="bg-gradient-to-r from-green-500 to-green-600 text-white p-4 rounded-lg shadow-lg">
                <h3 className="text-lg font-semibold">Workflows</h3>
                <p>{data.summary.totalWorkflows} disponibles</p>
              </div>
              <div className="bg-gradient-to-r from-purple-500 to-purple-600 text-white p-4 rounded-lg shadow-lg">
                <h3 className="text-lg font-semibold">Sources</h3>
                <p>{data.summary.totalSources} disponibles</p>
              </div>
              <div className="bg-gradient-to-r from-red-500 to-red-600 text-white p-4 rounded-lg shadow-lg">
                <h3 className="text-lg font-semibold">Targets</h3>
                <p>{data.summary.totalTargets} disponibles</p>
              </div>
            </div>
          </div>
        );
      case "mappings":
        const filteredMappings = data.mappings?.filter(mapping =>
          mapping.name?.toLowerCase().includes(searchTerm.toLowerCase())
        );
        return (
          <div className="p-6">
            <h2 className="text-2xl font-bold mb-4">Mappings</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredMappings?.map((mapping, index) => (
                <div
                  key={index}
                  className="bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow"
                >
                  <h3 className="text-lg font-semibold text-blue-600">
                    {mapping.name}
                  </h3>
                  <p className="text-gray-600">Estado: {mapping.isValid}</p>
                  <p className="text-gray-600">
                    Transformaciones: {mapping.transformations?.length || 0}
                  </p>
                </div>
              )) || <p>No hay mappings disponibles.</p>}
            </div>
          </div>
        );
      case "workflows":
        const filteredWorkflows = data.workflows?.filter(workflow =>
          workflow.name?.toLowerCase().includes(searchTerm.toLowerCase())
        );
        return (
          <div className="p-6">
            <h2 className="text-2xl font-bold mb-4">Workflows</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {filteredWorkflows.map((workflow, index) => (
                <div
                  key={index}
                  className="bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow"
                >
                  <h3 className="text-lg font-semibold text-green-600">
                    {workflow.name}
                  </h3>
                  <p className="text-gray-600">
                    Estado: {workflow.isValid} / {workflow.isEnabled}
                  </p>
                  <p className="text-gray-600">
                    Tareas: {workflow.tasks?.length || 0}
                  </p>
                </div>
              ))}
            </div>
          </div>
        );
      case "sources":
        const filteredSources = data.sources?.filter(source =>
          source.name?.toLowerCase().includes(searchTerm.toLowerCase())
        );
        return (
          <div className="p-6">
            <h2 className="text-2xl font-bold mb-4">Sources</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
              {filteredSources?.map((source, index) => (
                <div
                  key={index}
                  className="bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow"
                >
                  <h3 className="text-lg font-semibold text-purple-600">
                    {source.name}
                  </h3>
                  <p className="text-gray-600">
                    Tipo: {source.databaseType}
                  </p>
                  <div className="text-gray-600">
                    <p className="font-medium">Campos ({source.fields?.length || 0}):</p>
                    <div className="max-h-20 overflow-y-auto text-sm">
                      {source.fields?.slice(0, 5).map((field, idx) => (
                        <div key={idx} className="flex justify-between">
                          <span>{field.name}</span>
                          <span className="text-gray-500">{field.dataType}</span>
                        </div>
                      ))}
                      {(source.fields?.length || 0) > 5 && (
                        <p className="text-gray-400">... y {(source.fields.length - 5)} m치s</p>
                      )}
                    </div>
                  </div>
                </div>
              )) || <p>No hay sources disponibles.</p>}
            </div>
          </div>
        );
      case "targets":
        const filteredTargets = data.targets?.filter(target =>
          target.name?.toLowerCase().includes(searchTerm.toLowerCase())
        );
        return (
          <div className="p-6">
            <h2 className="text-2xl font-bold mb-4">Targets</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
              {filteredTargets?.map((target, index) => (
                <div
                  key={index}
                  className="bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow"
                >
                  <h3 className="text-lg font-semibold text-red-600">
                    {target.name}
                  </h3>
                  <p className="text-gray-600">
                    Tipo: {target.databaseType}
                  </p>
                  <div className="text-gray-600">
                    <p className="font-medium">Campos ({target.fields?.length || 0}):</p>
                    <div className="max-h-20 overflow-y-auto text-sm">
                      {target.fields?.slice(0, 5).map((field, idx) => (
                        <div key={idx} className="flex justify-between">
                          <span>{field.name}</span>
                          <span className="text-gray-500">{field.dataType}</span>
                        </div>
                      ))}
                      {(target.fields?.length || 0) > 5 && (
                        <p className="text-gray-400">... y {(target.fields.length - 5)} m치s</p>
                      )}
                    </div>
                  </div>
                </div>
              )) || <p>No hay targets disponibles.</p>}
            </div>
          </div>
        );
      case "sessions":
        const filteredSessions = data.sessions?.filter(session =>
          session.name?.toLowerCase().includes(searchTerm.toLowerCase())
        );

        return (
          <div className="p-6">
            <h2 className="text-2xl font-bold mb-4">Sessions</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredSessions?.map((session, index) => {
                // Ahora los detalles del mapeo se pueden buscar de data.mappings
                const mappedMapping = data.mappings.find(m => m.name === session.mappingName);

                const sourceNames = mappedMapping?.instances
                  .filter(inst => inst.type === 'SOURCE')
                  .map(inst => inst.name) || [];
                const targetNames = mappedMapping?.instances
                  .filter(inst => inst.type === 'TARGET')
                  .map(inst => inst.name) || [];
                const transformationNames = mappedMapping?.instances
                  .filter(inst => inst.type === 'TRANSFORMATION')
                  .map(inst => `${inst.name} (${inst.transformationType})`) || [];

                return (
                  <div
                    key={index}
                    className="bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition-shadow"
                  >
                    <h3 className="text-lg font-semibold text-green-600">
                      {session.name}
                    </h3>
                    <p className="text-gray-600">Mapping: {session.mappingName}</p>
                    <p className="text-gray-600">Estado: {session.isValid}</p>
                    <div className="text-gray-600 mt-2">
                      <p className="font-medium">Sources ({sourceNames.length}):</p>
                      <div className="max-h-16 overflow-y-auto text-sm">
                        {sourceNames.slice(0, 3).map((src, idx) => (
                          <div key={idx}>{src}</div>
                        ))}
                        {sourceNames.length > 3 && (
                          <p className="text-gray-400">... y {sourceNames.length - 3} m치s</p>
                        )}
                      </div>
                    </div>
                    <div className="text-gray-600 mt-2">
                      <p className="font-medium">Targets ({targetNames.length}):</p>
                      <div className="max-h-16 overflow-y-auto text-sm">
                        {targetNames.slice(0, 3).map((tgt, idx) => (
                          <div key={idx}>{tgt}</div>
                        ))}
                        {targetNames.length > 3 && (
                          <p className="text-gray-400">... y {targetNames.length - 3} m치s</p>
                        )}
                      </div>
                    </div>
                    <div className="text-gray-600 mt-2">
                      <p className="font-medium">Transformaciones ({transformationNames.length}):</p>
                      <div className="max-h-16 overflow-y-auto text-sm">
                        {transformationNames.slice(0, 5).map((trans, idx) => (
                          <div key={idx}>{trans}</div>
                        ))}
                        {transformationNames.length > 5 && (
                          <p className="text-gray-400">... y {(transformationNames.length - 5)} m치s</p>
                        )}
                      </div>
                    </div>
                  </div>
                );
              }) || <p>No hay sesiones disponibles.</p>}
            </div>
          </div>
        );
      default:
        return <div className="p-6">Selecciona una secci칩n.</div>;
    }
  };

  return (
    <div className="flex h-screen bg-gray-100">
      {/* Sidebar */}
      <div className="w-64 bg-gradient-to-b from-gray-800 to-gray-900 text-white shadow-lg">
        <div className="p-4">
          <h1 className="text-xl font-bold">PowerCenter ETL</h1>
        </div>
        <nav className="mt-4">
          {sections.map((section) => (
            <button
              key={section.id}
              onClick={() => setActiveSection(section.id)}
              className={`w-full text-left px-4 py-2 hover:bg-gray-700 transition-colors ${
                activeSection === section.id ? "bg-gray-700" : ""
              }`}
            >
              <span className="mr-2">{section.icon}</span>
              {section.name}
            </button>
          ))}
        </nav>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col">
        {/* Header */}
        <header className="bg-white shadow-md p-4 flex justify-between items-center">
          <h1 className="text-2xl font-bold text-gray-800">Dashboard ETL</h1>
          <div className="flex items-center space-x-4">
            <input
              type="text"
              placeholder="Buscar..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="px-3 py-1 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <div className="flex items-center space-x-2">
              <span>Usuario</span>
              <div className="w-8 h-8 bg-blue-500 rounded-full"></div>
            </div>
          </div>
        </header>

        {/* Content */}
        <main className="flex-1 overflow-y-auto">{renderContent()}</main>
      </div>
    </div>
  );
}

export default App;


--------------------------------------------------------------------------------

// src/extractor.ts

// src/extractor.ts
import * as fs from "fs";
import * as path from "path";
import { parseString } from "xml2js";
import {
  ensureArray,
  type IConfig,
  type IConnectionReference,
  type IConnector,
  type IExtractionResult,
  type IField,
  type IFlatExtractionData,
  type IInstance,
  type IMappedAttribute,
  type IMappedConfig,
  type IMappedConnectionReference,
  type IMappedConnector,
  type IMappedField,
  type IMappedInstance,
  type IMappedMapping,
  type IMappedMappingVariable,
  type IMappedMetadataExtension,
  type IMappedScheduler,
  type IMappedSession,
  type IMappedSessionComponent,
  type IMappedSessionExtension,
  type IMappedSessTransformationInst,
  type IMappedSource,
  type IMappedTarget,
  type IMappedTargetLoadOrder,
  type IMappedTask,
  type IMappedTaskInstance,
  type IMappedTransformation,
  type IMappedTransformField,
  type IMappedValuePair,
  type IMappedWorkflow,
  type IMappedWorkflowLink,
  type IMappedWorkflowVariable,
  type IMapping,
  type IMappingVariable,
  type IMetaDataExtension,
  type IScheduler,
  type ISession,
  type ISessionComponent,
  type ISessionExtension,
  type ISessTransformationInst,
  type ISource,
  type ITableAttribute,
  type ITarget,
  type ITargetLoadOrder,
  type ITask,
  type ITaskInstance,
  type ITransformation,
  type ITransformField,
  type IValuePair,
  type IWorkflow,
  type IWorkflowLink,
  type IWorkflowVariable,
} from "./interfaces";

const xmlFilePath = path.join(process.cwd(), "wkf_03_DI_CARGA_INDICADORES.XML");
const outputJsonFilePath = path.join(process.cwd(), "public/extraction.json"); // Guarda en public/

// --- Funciones de mapeo (para aplanar y simplificar la estructura) ---

function mapAttribute(attr: ITableAttribute): IMappedAttribute {
  return {
    name: attr.NAME,
    value: attr.VALUE,
  };
}

function mapField(field: IField): IMappedField {
  return {
    name: field.NAME,
    dataType: field.DATATYPE,
    keyType: field.KEYTYPE,
    nullable: field.NULLABLE,
    precision: field.PRECISION,
    scale: field.SCALE,
    description: field.DESCRIPTION,
    length: field.LENGTH,
    physicalLength: field.PHYSICALLENGTH,
    fieldProperty: field.FIELDPROPERTY,
    fieldType: field.FIELDTYPE,
    hidden: field.HIDDEN,
    level: field.LEVEL,
    occurs: field.OCCURS,
    offset: field.OFFSET,
    usage_flags: field.USAGE_FLAGS,
  };
}

function mapSource(source: ISource): IMappedSource {
  return {
    name: source.NAME,
    databaseType: source.DATABASETYPE,
    ownerName: source.OWNERNAME,
    description: source.DESCRIPTION,
    fields: ensureArray(source.SOURCEFIELD).map(mapField),
    isFlatFile: !!source.FLATFILE, // Comprueba si existe la etiqueta FLATFILE
    attributes: ensureArray(source.TABLEATTRIBUTE).map(mapAttribute),
  };
}

function mapTarget(target: ITarget): IMappedTarget {
  return {
    name: target.NAME,
    databaseType: target.DATABASETYPE,
    description: target.DESCRIPTION,
    fields: ensureArray(target.TARGETFIELD).map(mapField),
    attributes: ensureArray(target.TABLEATTRIBUTE).map(mapAttribute),
  };
}

function mapTransformField(field: ITransformField): IMappedTransformField {
  return {
    name: field.NAME,
    portType: field.PORTTYPE,
    dataType: field.DATATYPE,
    precision: field.PRECISION,
    scale: field.SCALE,
    expression: field.EXPRESSION,
    expressionType: field.EXPRESSIONTYPE,
    description: field.DESCRIPTION,
    isSortKey: field.ISSORTKEY,
    sortDirection: field.SORTDIRECTION,
    defaultValue: field.DEFAULTVALUE,
    pictureText: field.PICTURETEXT,
  };
}

function mapMetadataExtension(
  ext: IMetaDataExtension
): IMappedMetadataExtension {
  return {
    name: ext.NAME,
    value: ext.VALUE,
    dataType: ext.DATATYPE,
    description: ext.DESCRIPTION,
    vendorName: ext.VENDORNAME,
    domainName: ext.DOMAINNAME,
    isClientEditable: ext.ISCLIENTEDITABLE,
    isClientVisible: ext.ISCLIENTVISIBLE,
    isReusable: ext.ISREUSABLE,
    isShareRead: ext.ISSHAREREAD,
    isShareWrite: ext.ISSHAREWRITE,
    maxLength: ext.MAXLENGTH,
  };
}

function mapTransformation(trans: ITransformation): IMappedTransformation {
  return {
    name: trans.NAME,
    type: trans.TYPE,
    description: trans.DESCRIPTION,
    reusable: trans.REUSABLE,
    fields: ensureArray(trans.TRANSFORMFIELD).map(mapTransformField),
    attributes: ensureArray(trans.TABLEATTRIBUTE).map(mapAttribute),
    metadataExtensions: ensureArray(trans.METADATAEXTENSION).map(
      mapMetadataExtension
    ),
  };
}

function mapInstance(instance: IInstance): IMappedInstance {
  return {
    name: instance.NAME,
    type: instance.TYPE,
    transformationName: instance.TRANSFORMATION_NAME,
    transformationType: instance.TRANSFORMATION_TYPE,
    description: instance.DESCRIPTION,
    associatedSourceInstanceName: instance.ASSOCIATED_SOURCE_INSTANCE?.NAME,
    attributes: ensureArray(instance.TABLEATTRIBUTE).map(mapAttribute),
  };
}

function mapConnector(connector: IConnector): IMappedConnector {
  return {
    fromField: connector.FROMFIELD,
    fromInstance: connector.FROMINSTANCE,
    fromInstanceType: connector.FROMINSTANCETYPE,
    toField: connector.TOFIELD,
    toInstance: connector.TOINSTANCE,
    toInstanceType: connector.TOINSTANCETYPE,
  };
}

function mapTargetLoadOrder(tlo: ITargetLoadOrder): IMappedTargetLoadOrder {
  return {
    order: tlo.ORDER,
    targetInstance: tlo.TARGETINSTANCE,
  };
}

function mapMappingVariable(mv: IMappingVariable): IMappedMappingVariable {
  return {
    name: mv.NAME,
    dataType: mv.DATATYPE,
    isParam: mv.ISPARAM,
    defaultValue: mv.DEFAULTVALUE,
    precision: mv.PRECISION,
    scale: mv.SCALE,
    isExpressionVariable: mv.ISEXPRESSIONVARIABLE,
    userDefined: mv.USERDEFINED,
    description: mv.DESCRIPTION,
  };
}

function mapMapping(mapping: IMapping): IMappedMapping {
  return {
    name: mapping.NAME,
    isValid: mapping.ISVALID,
    description: mapping.DESCRIPTION,
    transformations: ensureArray(mapping.TRANSFORMATION).map(mapTransformation),
    instances: ensureArray(mapping.INSTANCE).map(mapInstance),
    connectors: ensureArray(mapping.CONNECTOR).map(mapConnector),
    targetLoadOrders: ensureArray(mapping.TARGETLOADORDER).map(
      mapTargetLoadOrder
    ),
    variables: ensureArray(mapping.MAPPINGVARIABLE).map(mapMappingVariable),
  };
}

function mapValuePair(vp: IValuePair): IMappedValuePair {
  return {
    name: vp.NAME,
    value: vp.VALUE,
    execOrder: vp.EXECORDER,
    reverseAssignment: vp.REVERSEASSIGNMENT,
  };
}

function mapTask(task: ITask): IMappedTask {
  return {
    name: task.NAME,
    type: task.TYPE,
    description: task.DESCRIPTION,
    reusable: task.REUSABLE,
    versionNumber: task.VERSIONNUMBER,
    attributes: ensureArray(task.ATTRIBUTE).map(mapAttribute),
    valuePairs: ensureArray(task.VALUEPAIR).map(mapValuePair),
  };
}

function mapTaskInstance(taskInst: ITaskInstance): IMappedTaskInstance {
  return {
    name: taskInst.NAME,
    taskName: taskInst.TASKNAME,
    taskType: taskInst.TASKTYPE,
    isEnabled: taskInst.ISENABLED,
    failParentIfFails: taskInst.FAIL_PARENT_IF_INSTANCE_FAILS,
    failParentIfDidNotRun: taskInst.FAIL_PARENT_IF_INSTANCE_DID_NOT_RUN,
    treatInputLinkAsAnd: taskInst.TREAT_INPUTLINK_AS_AND,
    attributes: ensureArray(taskInst.ATTRIBUTE).map(mapAttribute),
    description: taskInst.DESCRIPTION,
    reusable: taskInst.REUSABLE,
    decisionName: taskInst["Decision Name"], // Acceso directo al atributo del XML
  };
}

function mapWorkflowLink(link: IWorkflowLink): IMappedWorkflowLink {
  return {
    fromTask: link.FROMTASK,
    toTask: link.TOTASK,
    condition: link.CONDITION,
  };
}

function mapWorkflowVariable(
  wfVar: IWorkflowVariable
): IMappedWorkflowVariable {
  return {
    name: wfVar.NAME,
    dataType: wfVar.DATATYPE,
    userDefined: wfVar.USERDEFINED,
    defaultValue: wfVar.DEFAULTVALUE,
    isPersistent: wfVar.ISPERSISTENT,
    description: wfVar.DESCRIPTION,
    isNull: wfVar.ISNULL,
  };
}

function mapScheduler(scheduler: IScheduler): IMappedScheduler {
  return {
    name: scheduler.NAME,
    scheduleType: scheduler.SCHEDULEINFO?.SCHEDULETYPE || "UNKNOWN",
    description: scheduler.DESCRIPTION,
  };
}

function mapWorkflow(workflow: IWorkflow): IMappedWorkflow {
  return {
    name: workflow.NAME,
    isValid: workflow.ISVALID,
    isEnabled: workflow.ISENABLED,
    description: workflow.DESCRIPTION,
    serverName: workflow.SERVERNAME,
    tasks: ensureArray(workflow.TASKINSTANCE).map(mapTaskInstance),
    links: ensureArray(workflow.WORKFLOWLINK).map(mapWorkflowLink),
    variables: ensureArray(workflow.WORKFLOWVARIABLE).map(mapWorkflowVariable),
    attributes: ensureArray(workflow.ATTRIBUTE).map(mapAttribute),
    scheduler: mapScheduler(workflow.SCHEDULER),
  };
}

function mapSessTransformationInst(
  stInst: ISessTransformationInst
): IMappedSessTransformationInst {
  return {
    instanceName: stInst.SINSTANCENAME,
    transformationName: stInst.TRANSFORMATIONNAME,
    transformationType: stInst.TRANSFORMATIONTYPE,
    pipeline: stInst.PIPELINE,
    stage: stInst.STAGE,
    isRepartitionPoint: stInst.ISREPARTITIONPOINT,
    partitionType: stInst.PARTITIONTYPE,
    attributes: ensureArray(stInst.ATTRIBUTE).map(mapAttribute),
    partition: ensureArray(stInst.PARTITION).map((p) => ({
      name: p.NAME,
      description: p.DESCRIPTION,
    })),
  };
}

function mapConnectionReference(
  connRef: IConnectionReference
): IMappedConnectionReference {
  return {
    name: connRef.CNXREFNAME,
    type: connRef.CONNECTIONTYPE,
    variable: connRef.VARIABLE,
    connectionName: connRef.CONNECTIONNAME,
    connectionNumber: connRef.CONNECTIONNUMBER,
    connectionSubtype: connRef.CONNECTIONSUBTYPE,
  };
}

function mapSessionExtension(
  sessExt: ISessionExtension
): IMappedSessionExtension {
  return {
    name: sessExt.NAME,
    instanceName: sessExt.SINSTANCENAME,
    subType: sessExt.SUBTYPE,
    transformationType: sessExt.TRANSFORMATIONTYPE,
    type: sessExt.TYPE,
    connectionReference: sessExt.CONNECTIONREFERENCE
      ? mapConnectionReference(sessExt.CONNECTIONREFERENCE)
      : undefined,
    attributes: ensureArray(sessExt.ATTRIBUTE).map(mapAttribute),
    dsqInstanceName: sessExt.DSQINSTNAME,
    dsqInstanceType: sessExt.DSQINSTTYPE,
  };
}

function mapSessionComponent(
  sessComp: ISessionComponent
): IMappedSessionComponent {
  return {
    refObjectName: sessComp.REFOBJECTNAME,
    reusable: sessComp.REUSABLE,
    type: sessComp.TYPE,
  };
}

function mapSession(session: ISession): IMappedSession {
  return {
    name: session.NAME,
    mappingName: session.MAPPINGNAME,
    isValid: session.ISVALID,
    description: session.DESCRIPTION,
    reusable: session.REUSABLE,
    versionNumber: session.VERSIONNUMBER,
    sortOrder: session.SORTORDER,
    transformationInstances: ensureArray(session.SESSTRANSFORMATIONINST).map(
      mapSessTransformationInst
    ),
    sessionExtensions: ensureArray(session.SESSIONEXTENSION).map(
      mapSessionExtension
    ),
    attributes: ensureArray(session.ATTRIBUTE).map(mapAttribute),
    configReferenceName: session.CONFIGREFERENCE?.REFOBJECTNAME || "UNKNOWN",
    sessionComponents: ensureArray(session.SESSIONCOMPONENT).map(
      mapSessionComponent
    ),
  };
}

function mapConfig(config: IConfig): IMappedConfig {
  return {
    name: config.NAME,
    isDefault: config.ISDEFAULT,
    description: config.DESCRIPTION,
    versionNumber: config.VERSIONNUMBER,
    attributes: ensureArray(config.ATTRIBUTE).map(mapAttribute),
  };
}

// --- L칩gica principal de extracci칩n ---

fs.readFile(
  xmlFilePath,
  "utf8",
  (err: NodeJS.ErrnoException | null, data: string) => {
    if (err) {
      console.error("Error reading XML file:", err);
      return;
    }

    // Configuraci칩n de xml2js:
    // - explicitArray: false -> Los elementos hijos 칰nicos no se envuelven en un array.
    // - mergeAttrs: true    -> Los atributos XML se fusionan como propiedades directas del objeto.
    parseString(
      data,
      { explicitArray: false, mergeAttrs: true },
      (err: Error | null, result: IExtractionResult) => {
        if (err) {
          console.error("Error parsing XML:", err);
          return;
        }

        const powerMart = result.POWERMART;
        const folder = powerMart.REPOSITORY.FOLDER;

        const mappedSources = ensureArray(folder.SOURCE).map(mapSource);
        const mappedTargets = ensureArray(folder.TARGET).map(mapTarget);
        const mappedMappings = ensureArray(folder.MAPPING).map(mapMapping);
        const mappedSessions = ensureArray(folder.SESSION).map(mapSession);
        // Workflow es singular en este XML, por eso se maneja con un condicional
        const mappedWorkflows = folder.WORKFLOW
          ? [mapWorkflow(folder.WORKFLOW)]
          : [];
        const mappedConfigs = ensureArray(folder.CONFIG).map(mapConfig);
        const mappedReusableTasks = ensureArray(folder.TASK).map(mapTask); // Tareas directamente bajo FOLDER

        let allTasksInstances: IMappedTaskInstance[] = [];
        mappedWorkflows.forEach((wf) => {
          allTasksInstances = allTasksInstances.concat(wf.tasks);
        });

        const extractionResult: IFlatExtractionData = {
          repositoryName: powerMart.REPOSITORY.NAME,
          folderName: folder.NAME,
          summary: {
            totalWorkflows: mappedWorkflows.length,
            totalSessions: mappedSessions.length,
            totalMappings: mappedMappings.length,
            totalSources: mappedSources.length,
            totalTargets: mappedTargets.length,
            totalTransformations: mappedMappings.reduce(
              (acc, m) => acc + (m.transformations?.length || 0),
              0
            ),
          },
          mappings: mappedMappings,
          workflows: mappedWorkflows,
          sources: mappedSources,
          targets: mappedTargets,
          sessions: mappedSessions,
          configs: mappedConfigs,
          reusableTasks: mappedReusableTasks,
          allTasksInstances: allTasksInstances, // Todas las instancias de tareas de todos los workflows
        };

        console.log(JSON.stringify(extractionResult, null, 2));

        // Guardar en archivo
        fs.writeFileSync(
          outputJsonFilePath,
          JSON.stringify(extractionResult, null, 2)
        );
        console.log(`Extraction data saved to ${outputJsonFilePath}`);
      }
    );
  }
);


--------------------------------------------------------------------------------

/* src/index.css */

@import "tailwindcss";


--------------------------------------------------------------------------------

// src/main.tsx

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


--------------------------------------------------------------------------------

// src/vite-env.d.ts

/// <reference types="vite/client" />


--------------------------------------------------------------------------------

// src/assets/react.svg

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>


--------------------------------------------------------------------------------

// src/interfaces/index.ts

export * from './mapping.interface';
export * from './multi-workflow.interface';
export * from './powermart.interface';
export * from './sessiones.interface';
export * from './workflow.interface';


--------------------------------------------------------------------------------

// src/interfaces/mapping.interface.ts

// src/interfaces/mapping.interface.ts

/**
 * Atributos clave-valor que definen el comportamiento de diversos elementos.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITableAttribute {
  NAME: string;
  VALUE: string;
}

/**
 * Representa un mapeo (Mapping) que define el flujo de datos.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IMapping {
  NAME: string;
  ISVALID: "YES" | "NO";
  OBJECTVERSION: string;
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  TRANSFORMATION?: ITransformation[];
  INSTANCE?: IInstance[];
  CONNECTOR?: IConnector[];
  TARGETLOADORDER?: ITargetLoadOrder[];
  MAPPINGVARIABLE?: IMappingVariable[];
  ERPINFO?: object; // Etiqueta vac칤a en el XML
}

/**
 * Representa una transformaci칩n dentro de un mapeo (ej. Expression, Filter).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITransformation {
  NAME: string;
  TYPE:
    | "Source Qualifier"
    | "Expression"
    | "Filter"
    | "Aggregator"
    | "Joiner"
    | "Lookup Procedure"
    | "Update Strategy"
    | "Sorter"; // A침adido "Sorter"
  OBJECTVERSION: string;
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  TRANSFORMFIELD?: ITransformField[];
  TABLEATTRIBUTE?: ITableAttribute[];
  METADATAEXTENSION?: IMetaDataExtension[]; // Extensi칩n de metadatos (opcional)
}

/**
 * Representa un puerto (campo) dentro de una transformaci칩n.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITransformField {
  NAME: string;
  PORTTYPE:
    | "INPUT"
    | "OUTPUT"
    | "INPUT/OUTPUT"
    | "LOOKUP/OUTPUT"
    | "LOOKUP/RETURN/OUTPUT"
    | "INPUT/OUTPUT/MASTER";
  DATATYPE:
    | "nstring"
    | "date/time"
    | "decimal"
    | "string"
    | "integer"
    | "number(p,s)"
    | "varchar2"
    | "number"; // Tipos de datos extendidos
  PRECISION: string;
  SCALE: string;
  DEFAULTVALUE?: string;
  DESCRIPTION?: string;
  EXPRESSION?: string;
  EXPRESSIONTYPE?: "GENERAL" | "GROUPBY";
  PICTURETEXT?: string;
  // Espec칤ficos para transformaciones Sorter
  ISSORTKEY?: "YES" | "NO";
  SORTDIRECTION?: "ASCENDING" | "DESCENDING";
}

/**
 * Instancia de una transformaci칩n, fuente o destino dentro de un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IInstance {
  NAME: string;
  TYPE: "SOURCE" | "TARGET" | "TRANSFORMATION";
  TRANSFORMATION_NAME: string;
  TRANSFORMATION_TYPE: string;
  DESCRIPTION?: string;
  REUSABLE?: "YES" | "NO";
  DBDNAME?: string; // Presente para instancias de fuentes/destinos
  ASSOCIATED_SOURCE_INSTANCE?: {
    NAME: string;
  };
  TABLEATTRIBUTE?: ITableAttribute[]; // Las instancias tambi칠n pueden tener atributos (ej. "Table Name Prefix" para TARGET)
}

/**
 * Define la conexi칩n entre los puertos de dos instancias en un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConnector {
  FROMFIELD: string;
  FROMINSTANCE: string;
  FROMINSTANCETYPE: string;
  TOFIELD: string;
  TOINSTANCE: string;
  TOINSTANCETYPE: string;
}

/**
 * Define el orden de carga para los destinos en un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITargetLoadOrder {
  ORDER: string;
  TARGETINSTANCE: string;
}

/**
 * Una variable definida a nivel de mapeo (ej. $$AtributoPF).
 * Los atributos se fusionan como propiedades directas.
 */
export interface IMappingVariable {
  NAME: string;
  DATATYPE: string;
  ISPARAM: "YES" | "NO";
  USERDEFINED: "YES" | "NO";
  PRECISION: string;
  SCALE: string;
  DEFAULTVALUE?: string;
  DESCRIPTION?: string;
  ISEXPRESSIONVARIABLE?: "YES" | "NO";
}

/**
 * Extensi칩n de metadatos para transformaciones.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IMetaDataExtension {
  DATATYPE: string;
  DOMAINNAME: string;
  ISCLIENTEDITABLE: "YES" | "NO";
  ISCLIENTVISIBLE: "YES" | "NO";
  ISREUSABLE: "YES" | "NO";
  ISSHAREREAD: "YES" | "NO";
  ISSHAREWRITE: "YES" | "NO";
  MAXLENGTH: string;
  NAME: string;
  VALUE: string;
  VENDORNAME: string;
  DESCRIPTION?: string;
}


--------------------------------------------------------------------------------

// src/interfaces/multi-workflow.interface.ts

// src/interfaces/multi-workflow.interface.ts
// Importa las interfaces base sin el "$" para el mapeo
import type { IPowerMart } from "./powermart.interface";

/**
 * Helper para asegurar que un elemento siempre se trate como un array.
 * 칔til cuando `xml2js` con `explicitArray: false` devuelve un objeto simple
 * en lugar de un array de un objeto si solo hay un elemento.
 * @param item El elemento a normalizar.
 * @returns Un array de elementos (vac칤o si es undefined/null, o con el elemento/s).
 */
export function ensureArray<T>(item: T | T[] | undefined): T[] {
  if (item === undefined || item === null) {
    return [];
  }
  if (Array.isArray(item)) {
    return item;
  }
  return [item];
}

/**
 * Estructura de datos crudos extra칤da, coincidiendo con el XML.
 */
export interface IExtractionResult {
  POWERMART: IPowerMart;
}

/**
 * Representa la estructura de datos extra칤da y aplanada, m치s f치cil de consumir por la UI.
 * Evita la anidaci칩n profunda del XML y normaliza los tipos.
 */
export interface IFlatExtractionData {
  repositoryName: string;
  folderName: string;
  summary: {
    totalWorkflows: number;
    totalSessions: number;
    totalMappings: number;
    totalSources: number;
    totalTargets: number;
    totalTransformations: number;
  };
  mappings: IMappedMapping[];
  workflows: IMappedWorkflow[];
  sources: IMappedSource[];
  targets: IMappedTarget[];
  sessions: IMappedSession[];
  configs: IMappedConfig[];
  reusableTasks: IMappedTask[]; // Tareas definidas directamente bajo FOLDER
  allTasksInstances: IMappedTaskInstance[]; // Todas las instancias de tareas dentro de los workflows
}

/**
 * Estructura simplificada para una fuente mapeada.
 */
export interface IMappedSource {
  name: string;
  databaseType: string;
  ownerName: string;
  description?: string;
  fields: IMappedField[];
  isFlatFile: boolean;
  attributes?: IMappedAttribute[];
}

/**
 * Estructura simplificada para un destino mapeado.
 */
export interface IMappedTarget {
  name: string;
  databaseType: string;
  description?: string;
  fields: IMappedField[];
  attributes?: IMappedAttribute[];
}

/**
 * Estructura simplificada para un campo (columna) mapeado.
 */
export interface IMappedField {
  name: string;
  dataType: string;
  keyType: string;
  nullable: string;
  precision: string;
  scale: string;
  description?: string;
  length?: string;
  physicalLength?: string;
  fieldProperty?: string;
  fieldType?: string;
  hidden?: "YES" | "NO";
  level?: string;
  occurs?: string;
  offset?: string;
  usage_flags?: string;
}

/**
 * Estructura simplificada para un mapeo mapeado.
 */
export interface IMappedMapping {
  name: string;
  isValid: "YES" | "NO";
  description?: string;
  transformations: IMappedTransformation[];
  instances: IMappedInstance[];
  connectors: IMappedConnector[];
  targetLoadOrders: IMappedTargetLoadOrder[];
  variables: IMappedMappingVariable[];
}

/**
 * Estructura simplificada para una transformaci칩n mapeada.
 */
export interface IMappedTransformation {
  name: string;
  type: string;
  description?: string;
  reusable: "YES" | "NO";
  fields: IMappedTransformField[];
  attributes: IMappedAttribute[];
  metadataExtensions?: IMappedMetadataExtension[];
}

/**
 * Estructura simplificada para un campo de transformaci칩n mapeado.
 */
export interface IMappedTransformField {
  name: string;
  portType: string;
  dataType: string;
  precision: string;
  scale: string;
  expression?: string;
  expressionType?: string;
  description?: string;
  isSortKey?: "YES" | "NO";
  sortDirection?: "ASCENDING" | "DESCENDING";
  defaultValue?: string;
  pictureText?: string;
}

/**
 * Estructura simplificada para una instancia mapeada.
 */
export interface IMappedInstance {
  name: string;
  type: string;
  transformationName: string;
  transformationType: string;
  description?: string;
  associatedSourceInstanceName?: string;
  attributes?: IMappedAttribute[];
}

/**
 * Estructura simplificada para un conector mapeado.
 */
export interface IMappedConnector {
  fromField: string;
  fromInstance: string;
  fromInstanceType: string;
  toField: string;
  toInstance: string;
  toInstanceType: string;
}

/**
 * Estructura simplificada para un orden de carga de destino mapeado.
 */
export interface IMappedTargetLoadOrder {
  order: string;
  targetInstance: string;
}

/**
 * Estructura simplificada para una variable de mapeo mapeada.
 */
export interface IMappedMappingVariable {
  name: string;
  dataType: string;
  isParam: "YES" | "NO";
  defaultValue?: string;
  precision: string;
  scale: string;
  isExpressionVariable?: "YES" | "NO";
  userDefined: "YES" | "NO";
  description?: string;
}

/**
 * Estructura simplificada para una extensi칩n de metadatos mapeada.
 */
export interface IMappedMetadataExtension {
  name: string;
  value: string;
  dataType: string;
  description?: string;
  vendorName: string;
  domainName: string;
  isClientEditable: "YES" | "NO";
  isClientVisible: "YES" | "NO";
  isReusable: "YES" | "NO";
  isShareRead: "YES" | "NO";
  isShareWrite: "YES" | "NO";
  maxLength: string;
}

/**
 * Estructura simplificada para un workflow mapeado.
 */
export interface IMappedWorkflow {
  name: string;
  isValid: "YES" | "NO";
  isEnabled: "YES" | "NO";
  description?: string;
  serverName: string;
  tasks: IMappedTaskInstance[]; // Instancias de tareas/sesiones dentro de este workflow
  links: IMappedWorkflowLink[];
  variables: IMappedWorkflowVariable[];
  attributes: IMappedAttribute[];
  scheduler: IMappedScheduler;
}

/**
 * Estructura simplificada para una instancia de tarea mapeada.
 */
export interface IMappedTaskInstance {
  name: string;
  taskName: string;
  taskType: string;
  isEnabled: "YES" | "NO";
  failParentIfFails?: "YES" | "NO";
  failParentIfDidNotRun?: "YES" | "NO";
  treatInputLinkAsAnd?: "YES" | "NO";
  attributes?: IMappedAttribute[];
  // sessionExtensions?: IMappedSessionExtension[]; // Si las extensiones est치n directamente bajo la instancia de tarea (no en este XML)
  description?: string;
  reusable?: "YES" | "NO";
  decisionName?: string;
}

/**
 * Estructura simplificada para un enlace de workflow mapeado.
 */
export interface IMappedWorkflowLink {
  fromTask: string;
  toTask: string;
  condition?: string;
}

/**
 * Estructura simplificada para una variable de workflow mapeada.
 */
export interface IMappedWorkflowVariable {
  name: string;
  dataType: string;
  userDefined: "YES" | "NO";
  defaultValue?: string;
  isPersistent: "YES" | "NO";
  description?: string;
  isNull: "YES" | "NO";
}

/**
 * Estructura simplificada para un scheduler mapeado.
 */
export interface IMappedScheduler {
  name: string;
  scheduleType: string;
  description?: string;
}

/**
 * Estructura simplificada para una sesi칩n mapeada.
 */
export interface IMappedSession {
  name: string;
  mappingName: string;
  isValid: "YES" | "NO";
  description?: string;
  transformationInstances: IMappedSessTransformationInst[];
  sessionExtensions: IMappedSessionExtension[];
  attributes: IMappedAttribute[];
  configReferenceName: string;
  sessionComponents?: IMappedSessionComponent[];
  reusable: "YES" | "NO";
  versionNumber: string;
  sortOrder?: string;
}

/**
 * Estructura simplificada para una instancia de transformaci칩n de sesi칩n mapeada.
 */
export interface IMappedSessTransformationInst {
  instanceName: string;
  transformationName: string;
  transformationType: string;
  pipeline: string;
  stage: string;
  isRepartitionPoint: "YES" | "NO";
  partitionType: string;
  attributes?: IMappedAttribute[];
  partition?: {
    name: string;
    description?: string;
  }[];
}

/**
 * Estructura simplificada para una extensi칩n de sesi칩n mapeada.
 */
export interface IMappedSessionExtension {
  name: string;
  instanceName: string;
  subType: string;
  transformationType: string;
  type: string;
  connectionReference?: IMappedConnectionReference;
  attributes: IMappedAttribute[];
  dsqInstanceName?: string;
  dsqInstanceType?: string;
}

/**
 * Estructura simplificada para una referencia de conexi칩n mapeada.
 */
export interface IMappedConnectionReference {
  name: string;
  type: string;
  variable: string;
  connectionName?: string;
  connectionNumber?: string;
  connectionSubtype?: string;
}

/**
 * Estructura simplificada para un componente de sesi칩n mapeado.
 */
export interface IMappedSessionComponent {
  refObjectName: string;
  reusable: "YES" | "NO";
  type: string;
}

/**
 * Estructura simplificada para un atributo mapeado.
 */
export interface IMappedAttribute {
  name: string;
  value: string;
}

/**
 * Estructura simplificada para una configuraci칩n mapeada.
 */
export interface IMappedConfig {
  name: string;
  isDefault: "YES" | "NO";
  description?: string;
  attributes: IMappedAttribute[];
  versionNumber: string;
}

/**
 * Estructura simplificada para una tarea reutilizable mapeada (definida en la carpeta).
 */
export interface IMappedTask {
  name: string;
  type: string;
  description?: string;
  reusable: "YES" | "NO";
  attributes?: IMappedAttribute[];
  valuePairs?: IMappedValuePair[];
  versionNumber: string;
}

/**
 * Estructura simplificada para un par clave-valor mapeado.
 */
export interface IMappedValuePair {
  name: string;
  value: string;
  execOrder: string;
  reverseAssignment: "YES" | "NO";
}


--------------------------------------------------------------------------------

// src/interfaces/powermart.interface.ts

// src/interfaces/powermart.interface.ts
import type { IMapping, ITableAttribute } from './mapping.interface';
import type { ISession } from './sessiones.interface';
import type { IWorkflow, IConfig, ITask } from './workflow.interface';

/**
 * Representa el nodo ra칤z del documento XML de PowerCenter.
 * Los atributos se fusionan como propiedades directas debido a `mergeAttrs: true`.
 */
export interface IPowerMart {
  CREATION_DATE: string;
  REPOSITORY_VERSION: string;
  REPOSITORY: IRepository;
}

/**
 * Contiene la informaci칩n del repositorio y la carpeta principal.
 */
export interface IRepository {
  NAME: string;
  VERSION: string;
  CODEPAGE: string;
  DATABASETYPE: string;
  FOLDER: IFolder; // Asumiendo una sola carpeta principal por repositorio en este XML
}

/**
 * El contenedor principal para todos los objetos de ETL como
 * fuentes, destinos, mapeos, sesiones y workflows.
 */
export interface IFolder {
  NAME: string;
  GROUP?: string; // Presente pero vac칤o en el ejemplo
  OWNER: string;
  SHARED: "SHARED" | "NOTSHARED";
  DESCRIPTION?: string;
  PERMISSIONS?: string; // Ejemplo: "rwx---r--"
  UUID?: string;
  SOURCE?: ISource[];
  TARGET?: ITarget[];
  MAPPING?: IMapping[];
  SESSION?: ISession[];
  WORKFLOW?: IWorkflow; // Asumiendo un 칰nico workflow por archivo XML en este contexto
  CONFIG?: IConfig[];
  TASK?: ITask[]; // Tareas reutilizables definidas directamente en la carpeta
  ERPINFO?: object; // Etiqueta vac칤a en el XML de ejemplo
}

/**
 * Interfaz gen칠rica para un campo (columna) en una fuente o destino.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IField {
  NAME: string;
  DATATYPE: string; // Ej. "date", "varchar2", "number(p,s)"
  KEYTYPE: "PRIMARY KEY" | "NOT A KEY" | "PRIMARY FOREIGN KEY" | "FOREIGN KEY";
  NULLABLE: "NULL" | "NOTNULL";
  PRECISION: string; // Ej. "19", "200"
  SCALE: string;     // Ej. "0", "9"
  DESCRIPTION?: string;
  BUSINESSNAME?: string;
  FIELDNUMBER: string;
  PICTURETEXT?: string;
  // Atributos espec칤ficos para SOURCEFIELD (se hacen opcionales para reutilizar en TARGETFIELD)
  FIELDPROPERTY?: string; // Ej. "0"
  FIELDTYPE?: string;     // Ej. "ELEMITEM"
  HIDDEN?: "YES" | "NO";  // Ej. "NO"
  LENGTH?: string;        // Ej. "19", "0", "10"
  LEVEL?: string;         // Ej. "0"
  OCCURS?: string;        // Ej. "0"
  OFFSET?: string;        // Ej. "0", "19"
  PHYSICALLENGTH?: string; // Ej. "19", "200"
  PHYSICALOFFSET?: string; // Ej. "0", "19"
  USAGE_FLAGS?: string;   // Ej. ""
}

/**
 * Representa una definici칩n de fuente de datos (Source Definition).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISource {
  NAME: string;
  DATABASETYPE: string;
  DBDNAME: string;
  OWNERNAME: string;
  OBJECTVERSION: string;
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  BUSINESSNAME?: string; // Presente pero vac칤o en el ejemplo
  SOURCEFIELD?: IField[];
  FLATFILE?: IFlatFile; // Atributos espec칤ficos si es un archivo plano
  TABLEATTRIBUTE?: ITableAttribute[]; // Las fuentes tambi칠n pueden tener atributos, ej. `Base Table Name`
}

/**
 * Representa una definici칩n de destino de datos (Target Definition).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITarget {
  NAME: string;
  DATABASETYPE: string;
  OBJECTVERSION: string;
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  BUSINESSNAME?: string; // Presente pero vac칤o en el ejemplo
  CONSTRAINT?: string;   // Presente pero vac칤o en el ejemplo
  TABLEOPTIONS?: string; // Presente pero vac칤o en el ejemplo
  TARGETFIELD?: IField[];
  TABLEATTRIBUTE?: ITableAttribute[]; // Los destinos pueden tener atributos como Pre/Post SQL
}

/**
 * Propiedades espec칤ficas para fuentes de tipo Flat File.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IFlatFile {
  CODEPAGE: string; // Ej. "UTF-8"
  CONSECDELIMITERSASONE: "YES" | "NO"; // Ej. "NO"
  DELIMITED: "YES" | "NO"; // Ej. "YES"
  DELIMITERS: string; // Ej. ","
  ESCAPE_CHARACTER: string; // Ej. ""
  KEEPESCAPECHAR: "YES" | "NO"; // Ej. "NO"
  LINESEQUENTIAL: "YES" | "NO"; // Ej. "NO"
  MULTIDELIMITERSASAND: "YES" | "NO"; // Ej. "YES"
  NULLCHARTYPE: string; // Ej. "ASCII"
  NULL_CHARACTER: string; // Ej. "*"
  PADBYTES: string; // Ej. "1"
  QUOTE_CHARACTER: "SINGLE" | "DOUBLE" | "NONE"; // Ej. "DOUBLE"
  REPEATABLE: "YES" | "NO"; // Ej. "NO"
  ROWDELIMITER: string; // Ej. "10"
  SHIFTSENSITIVEDATA: "YES" | "NO"; // Ej. "NO"
  SKIPROWS: string; // Ej. "1"
  STRIPTRAILINGBLANKS: "YES" | "NO"; // Ej. "NO"
}


--------------------------------------------------------------------------------

// src/interfaces/sessiones.interface.ts

// src/interfaces/sessiones.interface.ts
import type { ITableAttribute } from './mapping.interface';

/**
 * Representa una sesi칩n, que es la instancia ejecutable de un mapeo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISession {
  NAME: string;
  MAPPINGNAME: string;
  ISVALID: "YES" | "NO";
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  SORTORDER?: string; // Ej. "Binary"
  SESSTRANSFORMATIONINST?: ISessTransformationInst[];
  SESSIONEXTENSION?: ISessionExtension[];
  ATTRIBUTE?: ITableAttribute[];
  CONFIGREFERENCE: IConfigReference;
  SESSIONCOMPONENT?: ISessionComponent[]; // Componentes reutilizables (ej. Email_Failed)
}

/**
 * Instancia de una transformaci칩n dentro de una sesi칩n, define propiedades
 * como el particionamiento.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISessTransformationInst {
  SINSTANCENAME: string;
  TRANSFORMATIONNAME: string;
  TRANSFORMATIONTYPE: string;
  PIPELINE: string;
  STAGE: string;
  ISREPARTITIONPOINT: "YES" | "NO";
  PARTITIONTYPE: "PASS THROUGH" | "HASH AUTO KEYS" | "ROUND ROBIN" | string;
  DESCRIPTION?: string; // En algunos casos, la instancia de transformaci칩n tiene una descripci칩n
  // Un <SESSTRANSFORMATIONINST> puede contener <ATTRIBUTE> (para atributos de partici칩n)
  ATTRIBUTE?: ITableAttribute[];
  // Puede contener tambi칠n una etiqueta <PARTITION> con sus propios atributos.
  PARTITION?: {
    NAME: string;
    DESCRIPTION?: string;
  }[];
}

/**
 * Define configuraciones espec칤ficas para conexiones de la sesi칩n
 * (lectores, escritores, lookups).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISessionExtension {
  NAME: string; // Ej. "Relational Writer", "Relational Reader", "Relational Lookup"
  SINSTANCENAME: string;
  SUBTYPE: string; // Ej. "Relational Writer", "Relational Lookup"
  TRANSFORMATIONTYPE: string; // Ej. "Target Definition", "Source Qualifier", "Lookup Procedure"
  TYPE: "READER" | "WRITER" | "LOOKUPEXTENSION";
  // Atributos espec칤ficos para extensiones de Source Qualifier
  DSQINSTNAME?: string;
  DSQINSTTYPE?: string;
  CONNECTIONREFERENCE?: IConnectionReference; // Esto es una etiqueta hija
  ATTRIBUTE?: ITableAttribute[]; // Esto es una etiqueta hija
}

/**
 * Referencia a una conexi칩n de base de datos o de otro tipo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConnectionReference {
  CNXREFNAME: string;
  CONNECTIONTYPE: "Relational" | "Application" | string;
  VARIABLE: string;
  CONNECTIONNAME?: string;
  CONNECTIONNUMBER?: string;
  CONNECTIONSUBTYPE?: string;
}

/**
 * Referencia a un objeto de configuraci칩n.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConfigReference {
  TYPE: string;
  REFOBJECTNAME: string;
}

/**
 * Referencia a un componente de sesi칩n reutilizable (ej. una tarea de Email para notificaci칩n de fallo).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ISessionComponent {
  REFOBJECTNAME: string;
  REUSABLE: "YES" | "NO";
  TYPE: "Failure Email" | string;
}


--------------------------------------------------------------------------------

// src/interfaces/workflow.interface.ts

// src/interfaces/workflow.interface.ts
import type { ITableAttribute } from './mapping.interface';

/**
 * Representa el flujo de trabajo (Workflow) que orquesta la ejecuci칩n de tareas.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IWorkflow {
  NAME: string;
  ISVALID: "YES" | "NO";
  ISENABLED: "YES" | "NO";
  VERSIONNUMBER: string;
  SERVERNAME: string;
  SERVER_DOMAINNAME: string;
  DESCRIPTION?: string;
  REUSABLE_SCHEDULER?: "NO";
  SCHEDULERNAME?: string; // Ejemplo: "Scheduler"
  SUSPEND_ON_ERROR?: "YES" | "NO";
  TASKS_MUST_RUN_ON_SERVER?: "YES" | "NO";
  SCHEDULER: IScheduler;
  TASK?: ITask[]; // Tareas reutilizables definidas directamente en la carpeta
  TASKINSTANCE?: ITaskInstance[];
  WORKFLOWLINK?: IWorkflowLink[];
  WORKFLOWVARIABLE?: IWorkflowVariable[];
  ATTRIBUTE?: ITableAttribute[]; // Atributos a nivel de workflow como el Parameter Filename
}

/**
 * Una tarea reutilizable definida en la carpeta (ej. Email, Command).
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITask {
  NAME: string;
  TYPE: "Email" | "Command" | "Decision" | "Assignment" | "Start";
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  ATTRIBUTE?: ITableAttribute[];
  VALUEPAIR?: IValuePair[]; // Para tareas de Command, Decision, Assignment
}

/**
 * Representa un par clave-valor, a menudo utilizado en tareas de comando para par치metros.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IValuePair {
  EXECORDER: string;
  NAME: string;
  REVERSEASSIGNMENT: "YES" | "NO";
  VALUE: string;
}

/**
 * Instancia de una tarea o sesi칩n dentro del flujo de trabajo.
 * Los atributos se fusionan como propiedades directas.
 */
export interface ITaskInstance {
  NAME: string;
  TASKNAME: string;
  TASKTYPE: "Start" | "Session" | "Command" | "Decision" | "Assignment";
  ISENABLED: "YES" | "NO";
  // Atributos adicionales presentes en TASKINSTANCE en el XML:
  DESCRIPTION?: string;
  REUSABLE?: "YES" | "NO";
  FAIL_PARENT_IF_INSTANCE_DID_NOT_RUN?: "NO";
  FAIL_PARENT_IF_INSTANCE_FAILS?: "NO";
  TREAT_INPUTLINK_AS_AND?: "YES";
  // Espec칤ficos para tareas Decision
  "Decision Name"?: string; // Nombre del atributo en el XML
  ATTRIBUTE?: ITableAttribute[]; // Las instancias de tareas pueden tener atributos
  // Aunque el ejemplo no las muestra, una instancia de tarea podr칤a tener SessionExtension
  // si es una sesi칩n con overrides en l칤nea. De momento no se a침ade aqu칤.
}

/**
 * Define un enlace de ejecuci칩n entre dos instancias de tareas.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IWorkflowLink {
  FROMTASK: string;
  TOTASK: string;
  CONDITION?: string; // Condici칩n para el enlace
}

/**
 * Define una variable a nivel de workflow.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IWorkflowVariable {
  NAME: string;
  DATATYPE: string;
  USERDEFINED: "YES" | "NO";
  ISNULL: "YES" | "NO";
  ISPERSISTENT: "YES" | "NO";
  DEFAULTVALUE?: string;
  DESCRIPTION?: string;
}

/**
 * Define la configuraci칩n de scheduling del workflow.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IScheduler {
  NAME: string;
  REUSABLE: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  SCHEDULEINFO: IScheduleInfo;
}

/**
 * Detalles sobre el schedule.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IScheduleInfo {
  SCHEDULETYPE: "ONDEMAND" | "RUNONCE" | "RUNONSERVERINIT" | string;
}

/**
 * Configuraci칩n por defecto de la sesi칩n.
 * Los atributos se fusionan como propiedades directas.
 */
export interface IConfig {
  NAME: string;
  ISDEFAULT: "YES" | "NO";
  VERSIONNUMBER: string;
  DESCRIPTION?: string;
  ATTRIBUTE?: ITableAttribute[];
}


--------------------------------------------------------------------------------

